/*!
 * @overview  Ember Data
 * @copyright Copyright 2011-2013 Tilde Inc. and contributors.
 *            Portions Copyright 2011 LivingSocial Inc.
 * @license   Licensed under MIT license (see license.js)
 * @version   1.0.0-beta.5+canary.972de818
 */


var define, requireModule;

(function() {
  var registry = {}, seen = {};

  define = function(name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  requireModule = function(name) {
    if (seen[name]) { return seen[name]; }
    seen[name] = {};

    var mod, deps, callback, reified , exports;

    mod = registry[name];

    if (!mod) {
      throw new Error("Module '" + name + "' not found.");
    }

    deps = mod.deps;
    callback = mod.callback;
    reified = [];
    exports;

    for (var i=0, l=deps.length; i<l; i++) {
      if (deps[i] === 'exports') {
        reified.push(exports = {});
      } else {
        reified.push(requireModule(deps[i]));
      }
    }

    var value = callback.apply(this, reified);
    return seen[name] = exports || value;
  };
})();
minispade.register('ember-data/adapters', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/adapters/fixture_adapter\");\nminispade.require(\"ember-data/adapters/rest_adapter\");\n\n})();\n//@ sourceURL=ember-data/adapters");minispade.register('ember-data/adapters/fixture_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require(\"ember-data/system/adapter\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, fmt = Ember.String.fmt,\n    indexOf = Ember.EnumerableUtils.indexOf;\n\nvar counter = 0;\n\n/**\n  `DS.FixtureAdapter` is an adapter that loads records from memory.\n  Its primarily used for development and testing. You can also use\n  `DS.FixtureAdapter` while working on the API but are not ready to\n  integrate yet. It is a fully functioning adapter. All CRUD methods\n  are implemented. You can also implement query logic that a remote\n  system would do. Its possible to do develop your entire application\n  with `DS.FixtureAdapter`.\n\n  @class FixtureAdapter\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.FixtureAdapter = DS.Adapter.extend({\n  // by default, fixtures are already in normalized form\n  serializer: null,\n\n  simulateRemoteResponse: true,\n\n  latency: 50,\n\n  /**\n    Implement this method in order to provide data associated with a type\n\n    @method fixturesForType\n    @param  type\n  */\n  fixturesForType: function(type) {\n    if (type.FIXTURES) {\n      var fixtures = Ember.A(type.FIXTURES);\n      return fixtures.map(function(fixture){\n        var fixtureIdType = typeof fixture.id;\n        if(fixtureIdType !== \"number\" && fixtureIdType !== \"string\"){\n          throw new Error(fmt('the id property must be defined as a number or string for fixture %@', [fixture]));\n        }\n        fixture.id = fixture.id + '';\n        return fixture;\n      });\n    }\n    return null;\n  },\n\n  /**\n    Implement this method in order to query fixtures data\n\n    @method queryFixtures\n    @param  fixture\n    @param  query\n    @param  type\n  */\n  queryFixtures: function(fixtures, query, type) {\n    Ember.assert('Not implemented: You must override the DS.FixtureAdapter::queryFixtures method to support querying the fixture store.');\n  },\n\n  /**\n    @method updateFixtures\n    @param  type\n    @param  fixture\n  */\n  updateFixtures: function(type, fixture) {\n    if(!type.FIXTURES) {\n      type.FIXTURES = [];\n    }\n\n    var fixtures = type.FIXTURES;\n\n    this.deleteLoadedFixture(type, fixture);\n\n    fixtures.push(fixture);\n  },\n\n  /**\n    Implement this method in order to provide json for CRUD methods\n\n    @method mockJSON\n    @param  type\n    @param  record\n  */\n  mockJSON: function(store, type, record) {\n    return store.serializerFor(type).serialize(record, { includeId: true });\n  },\n\n  /**\n    @method generateIdForRecord\n    @param  store\n    @param  record\n  */\n  generateIdForRecord: function(store) {\n    return \"fixture-\" + counter++;\n  },\n\n  /**\n    @method find\n    @param  store\n    @param  type\n    @param  id\n  */\n  find: function(store, type, id) {\n    var fixtures = this.fixturesForType(type),\n        fixture;\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    if (fixtures) {\n      fixture = Ember.A(fixtures).findProperty('id', id);\n    }\n\n    if (fixture) {\n      return this.simulateRemoteCall(function() {\n        return fixture;\n      }, this);\n    }\n  },\n\n  /**\n    @method findMany\n    @param  store\n    @param  type\n    @param  ids\n  */\n  findMany: function(store, type, ids) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    if (fixtures) {\n      fixtures = fixtures.filter(function(item) {\n        return indexOf(ids, item.id) !== -1;\n      });\n    }\n\n    if (fixtures) {\n      return this.simulateRemoteCall(function() {\n        return fixtures;\n      }, this);\n    }\n  },\n\n  /**\n    @private\n    @method findAll\n    @param  store\n    @param  type\n  */\n  findAll: function(store, type) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    return this.simulateRemoteCall(function() {\n      return fixtures;\n    }, this);\n  },\n\n  /**\n    @private\n    @method findQuery\n    @param  store\n    @param  type\n    @param  query\n    @param  array\n  */\n  findQuery: function(store, type, query, array) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    fixtures = this.queryFixtures(fixtures, query, type);\n\n    if (fixtures) {\n      return this.simulateRemoteCall(function() {\n        return fixtures;\n      }, this);\n    }\n  },\n\n  /**\n    @method createRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  createRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.updateFixtures(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      return fixture;\n    }, this);\n  },\n\n  /**\n    @method updateRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  updateRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.updateFixtures(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      return fixture;\n    }, this);\n  },\n\n  /**\n    @method deleteRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  deleteRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.deleteLoadedFixture(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      // no payload in a deletion\n      return null;\n    });\n  },\n\n  /*\n    @method deleteLoadedFixture\n    @private\n    @param type\n    @param record\n  */\n  deleteLoadedFixture: function(type, record) {\n    var existingFixture = this.findExistingFixture(type, record);\n\n    if(existingFixture) {\n      var index = indexOf(type.FIXTURES, existingFixture);\n      type.FIXTURES.splice(index, 1);\n      return true;\n    }\n  },\n\n  /*\n    @method findExistingFixture\n    @private\n    @param type\n    @param record\n  */\n  findExistingFixture: function(type, record) {\n    var fixtures = this.fixturesForType(type);\n    var id = get(record, 'id');\n\n    return this.findFixtureById(fixtures, id);\n  },\n\n  /*\n    @method findFixtureById\n    @private\n    @param fixtures\n    @param id\n  */\n  findFixtureById: function(fixtures, id) {\n    return Ember.A(fixtures).find(function(r) {\n      if(''+get(r, 'id') === ''+id) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  },\n\n  /*\n    @method simulateRemoteCall\n    @private\n    @param callback\n    @param context\n  */\n  simulateRemoteCall: function(callback, context) {\n    var adapter = this;\n\n    return new Ember.RSVP.Promise(function(resolve) {\n      if (get(adapter, 'simulateRemoteResponse')) {\n        // Schedule with setTimeout\n        Ember.run.later(function() {\n          resolve(callback.call(context));\n        }, get(adapter, 'latency'));\n      } else {\n        // Asynchronous, but at the of the runloop with zero latency\n        Ember.run.schedule('actions', null, function() {\n          resolve(callback.call(context));\n        });\n      }\n    }, \"DS: FixtureAdapter#simulateRemoteCall\");\n  }\n});\n\n})();\n//@ sourceURL=ember-data/adapters/fixture_adapter");minispade.register('ember-data/adapters/rest_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require('ember-data/system/adapter');\nminispade.require('ember-data/serializers/rest_serializer');\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.ArrayPolyfills.forEach;\n\n/**\n  The REST adapter allows your store to communicate with an HTTP server by\n  transmitting JSON via XHR. Most Ember.js apps that consume a JSON API\n  should use the REST adapter.\n\n  This adapter is designed around the idea that the JSON exchanged with\n  the server should be conventional.\n\n  ## JSON Structure\n\n  The REST adapter expects the JSON returned from your server to follow\n  these conventions.\n\n  ### Object Root\n\n  The JSON payload should be an object that contains the record inside a\n  root property. For example, in response to a `GET` request for\n  `/posts/1`, the JSON should look like this:\n\n  ```js\n  {\n    \"post\": {\n      title: \"I'm Running to Reform the W3C's Tag\",\n      author: \"Yehuda Katz\"\n    }\n  }\n  ```\n\n  ### Conventional Names\n\n  Attribute names in your JSON payload should be the camelCased versions of\n  the attributes in your Ember.js models.\n\n  For example, if you have a `Person` model:\n\n  ```js\n  App.Person = DS.Model.extend({\n    firstName: DS.attr('string'),\n    lastName: DS.attr('string'),\n    occupation: DS.attr('string')\n  });\n  ```\n\n  The JSON returned should look like this:\n\n  ```js\n  {\n    \"person\": {\n      \"firstName\": \"Barack\",\n      \"lastName\": \"Obama\",\n      \"occupation\": \"President\"\n    }\n  }\n  ```\n\n  ## Customization\n\n  ### Endpoint path customization\n\n  Endpoint paths can be prefixed with a `namespace` by setting the namespace\n  property on the adapter:\n\n  ```js\n  DS.RESTAdapter.reopen({\n    namespace: 'api/1'\n  });\n  ```\n  Requests for `App.Person` would now target `/api/1/people/1`.\n\n  ### Host customization\n\n  An adapter can target other hosts by setting the `host` property.\n\n  ```js\n  DS.RESTAdapter.reopen({\n    host: 'https://api.example.com'\n  });\n  ```\n\n  ### Headers customization\n\n  Some APIs require HTTP headers, e.g. to provide an API key. An array of\n  headers can be added to the adapter which are passed with every request:\n\n  ```js\n  DS.RESTAdapter.reopen({\n    headers: {\n      \"API_KEY\": \"secret key\",\n      \"ANOTHER_HEADER\": \"Some header value\"\n    }\n  });\n  ```\n\n  @class RESTAdapter\n  @constructor\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.RESTAdapter = DS.Adapter.extend({\n  defaultSerializer: '_rest',\n\n  /**\n    Called by the store in order to fetch the JSON for a given\n    type and ID.\n\n    The `find` method makes an Ajax request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    This method performs an HTTP `GET` request with the id provided as part of the querystring.\n\n    @method find\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {String} id\n    @returns Promise\n  */\n  find: function(store, type, id) {\n    return this.ajax(this.buildURL(type.typeKey, id), 'GET');\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for all\n    of the records for a given type.\n\n    The `findAll` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @private\n    @method findAll\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {String} sinceToken\n    @returns Promise\n  */\n  findAll: function(store, type, sinceToken) {\n    var query;\n\n    if (sinceToken) {\n      query = { since: sinceToken };\n    }\n\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: query });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the records that match a particular query.\n\n    The `findQuery` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    The `query` argument is a simple JavaScript object that will be passed directly\n    to the server as parameters.\n\n    @private\n    @method findQuery\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} query\n    @returns Promise\n  */\n  findQuery: function(store, type, query) {\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: query });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a has-many relationship that were originally\n    specified as IDs.\n\n    For example, if the original payload looks like:\n\n    ```js\n    {\n      \"id\": 1,\n      \"title\": \"Rails is omakase\",\n      \"comments\": [ 1, 2, 3 ]\n    }\n    ```\n\n    The IDs will be passed as a URL-encoded Array of IDs, in this form:\n\n    ```\n    ids[]=1&ids[]=2&ids[]=3\n    ```\n\n    Many servers, such as Rails and PHP, will automatically convert this URL-encoded array\n    into an Array for you on the server-side. If you want to encode the\n    IDs, differently, just override this (one-line) method.\n\n    The `findMany` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @method findMany\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Array<String>} ids\n    @returns Promise\n  */\n  findMany: function(store, type, ids) {\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: { ids: ids } });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a has-many relationship that were originally\n    specified as a URL (inside of `links`).\n\n    For example, if your original payload looks like this:\n\n    ```js\n    {\n      \"post\": {\n        \"id\": 1,\n        \"title\": \"Rails is omakase\",\n        \"links\": { \"comments\": \"/posts/1/comments\" }\n      }\n    }\n    ```\n\n    This method will be called with the parent record and `/posts/1/comments`.\n\n    The `findHasMany` method will make an Ajax (HTTP GET) request to the originally specified URL.\n    If the URL is host-relative (starting with a single slash), the\n    request will use the host specified on the adapter (if any).\n\n    @method findHasMany\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {DS.Model} record\n    @param {String} url\n    @returns Promise\n  */\n  findHasMany: function(store, record, url) {\n    var host = get(this, 'host'),\n        id   = get(record, 'id'),\n        type = record.constructor.typeKey;\n\n    if (host && url.charAt(0) === '/' && url.charAt(1) !== '/') {\n      url = host + url;\n    }\n\n    return this.ajax(this.urlPrefix(url, this.buildURL(type, id)), 'GET');\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a belongs-to relationship that were originally\n    specified as a URL (inside of `links`).\n\n    For example, if your original payload looks like this:\n\n    ```js\n    {\n      \"person\": {\n        \"id\": 1,\n        \"name\": \"Tom Dale\",\n        \"links\": { \"group\": \"/people/1/group\" }\n      }\n    }\n    ```\n\n    This method will be called with the parent record and `/people/1/group`.\n\n    The `findBelongsTo` method will make an Ajax (HTTP GET) request to the originally specified URL.\n\n    @method findBelongsTo\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {DS.Model} record\n    @param {String} url\n    @returns Promise\n  */\n  findBelongsTo: function(store, record, url) {\n    var id   = get(record, 'id'),\n        type = record.constructor.typeKey;\n\n    return this.ajax(this.urlPrefix(url, this.buildURL(type, id)), 'GET');\n  },\n\n  /**\n    Called by the store when a newly created record is\n    saved via the `save` method on a model record instance.\n\n    The `createRecord` method serializes the record and makes an Ajax (HTTP POST) request\n    to a URL computed by `buildURL`.\n\n    See `serialize` for information on how to customize the serialized form\n    of a record.\n\n    @method createRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  createRecord: function(store, type, record) {\n    var data = {};\n    var serializer = store.serializerFor(type.typeKey);\n\n    serializer.serializeIntoHash(data, type, record, { includeId: true });\n\n    return this.ajax(this.buildURL(type.typeKey), \"POST\", { data: data });\n  },\n\n  /**\n    Called by the store when an existing record is saved\n    via the `save` method on a model record instance.\n\n    The `updateRecord` method serializes the record and makes an Ajax (HTTP PUT) request\n    to a URL computed by `buildURL`.\n\n    See `serialize` for information on how to customize the serialized form\n    of a record.\n\n    @method updateRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  updateRecord: function(store, type, record) {\n    var data = {};\n    var serializer = store.serializerFor(type.typeKey);\n\n    serializer.serializeIntoHash(data, type, record);\n\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type.typeKey, id), \"PUT\", { data: data });\n  },\n\n  /**\n    Called by the store when a record is deleted.\n\n    The `deleteRecord` method  makes an Ajax (HTTP DELETE) request to a URL computed by `buildURL`.\n\n    @method deleteRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  deleteRecord: function(store, type, record) {\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type.typeKey, id), \"DELETE\");\n  },\n\n  /**\n    Builds a URL for a given type and optional ID.\n\n    By default, it pluralizes the type's name (for example,\n    'post' becomes 'posts' and 'person' becomes 'people').\n\n    If an ID is specified, it adds the ID to the path generated\n    for the type, separated by a `/`.\n\n    @method buildURL\n    @param {String} type\n    @param {String} id\n    @returns String\n  */\n  buildURL: function(type, id) {\n    var url = [],\n        host = get(this, 'host'),\n        prefix = this.urlPrefix();\n\n    if (type) { url.push(this.pathForType(type)); }\n    if (id) { url.push(id); }\n\n    if (prefix) { url.unshift(prefix); }\n\n    url = url.join('/');\n    if (!host && url) { url = '/' + url; }\n\n    return url;\n  },\n\n  urlPrefix: function(path, parentURL) {\n    var host = get(this, 'host'),\n        namespace = get(this, 'namespace'),\n        url = [];\n\n    if (path) {\n      // Absolute path\n      if (path.charAt(0) === '/') {\n        if (host) {\n          path = path.slice(1);\n          url.push(host);\n        }\n      // Relative path\n      } else if (!/^http(s)?:\\/\\//.test(path)) {\n        url.push(parentURL);\n      }\n    } else {\n      if (host) { url.push(host); }\n      if (namespace) { url.push(namespace); }\n    }\n\n    if (path) {\n      url.push(path);\n    }\n\n    return url.join('/');\n  },\n\n  /**\n    Determines the pathname for a given type.\n\n    By default, it pluralizes the type's name (for example,\n    'post' becomes 'posts' and 'person' becomes 'people').\n\n    ### Pathname customization\n\n    For example if you have an object LineItem with an\n    endpoint of \"/line_items/\".\n\n    ```js\n    DS.RESTAdapter.reopen({\n      pathForType: function(type) {\n        var decamelized = Ember.String.decamelize(type);\n        return Ember.String.pluralize(decamelized);\n      };\n    });\n    ```\n\n    @method pathForType\n    @param {String} type\n    @returns String\n  **/\n  pathForType: function(type) {\n    return Ember.String.pluralize(type);\n  },\n\n  /**\n    Takes an ajax response, and returns a relavant error.\n\n    By default, the `ajaxError` method has the following behavior:\n\n    * It simply returns the ajax response (jqXHR).\n\n    @method ajaxError\n    @param  jqXHR\n  */\n  ajaxError: function(jqXHR) {\n    if (jqXHR) {\n      jqXHR.then = null;\n    }\n\n    return jqXHR;\n  },\n\n  /**\n    Takes a URL, an HTTP method and a hash of data, and makes an\n    HTTP request.\n\n    When the server responds with a payload, Ember Data will call into `extractSingle`\n    or `extractArray` (depending on whether the original query was for one record or\n    many records).\n\n    By default, `ajax` method has the following behavior:\n\n    * It sets the response `dataType` to `\"json\"`\n    * If the HTTP method is not `\"GET\"`, it sets the `Content-Type` to be\n      `application/json; charset=utf-8`\n    * If the HTTP method is not `\"GET\"`, it stringifies the data passed in. The\n      data is the serialized record in the case of a save.\n    * Registers success and failure handlers.\n\n    @method ajax\n    @private\n    @param  url\n    @param  type\n    @param  hash\n  */\n  ajax: function(url, type, hash) {\n    var adapter = this;\n\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n      hash = adapter.ajaxOptions(url, type, hash);\n\n      hash.success = function(json) {\n        Ember.run(null, resolve, json);\n      };\n\n      hash.error = function(jqXHR, textStatus, errorThrown) {\n        Ember.run(null, reject, adapter.ajaxError(jqXHR));\n      };\n\n      Ember.$.ajax(hash);\n    }, \"DS: RestAdapter#ajax \" + type + \" to \" + url);\n  },\n\n  ajaxOptions: function(url, type, hash) {\n    hash = hash || {};\n    hash.url = url;\n    hash.type = type;\n    hash.dataType = 'json';\n    hash.context = this;\n\n    if (hash.data && type !== 'GET') {\n      hash.contentType = 'application/json; charset=utf-8';\n      hash.data = JSON.stringify(hash.data);\n    }\n\n    if (this.headers !== undefined) {\n      var headers = this.headers;\n      hash.beforeSend = function (xhr) {\n        forEach.call(Ember.keys(headers), function(key) {\n          xhr.setRequestHeader(key, headers[key]);\n        });\n      };\n    }\n\n\n    return hash;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/adapters/rest_adapter");minispade.register('ember-data/core', "(function() {/**\n  @module ember-data\n*/\n\n/**\n  All Ember Data methods and functions are defined inside of this namespace.\n\n  @class DS\n  @static\n*/\nvar DS;\nif ('undefined' === typeof DS) {\n  DS = Ember.Namespace.create({\n    VERSION: '1.0.0-beta.5+canary.972de818'\n  });\n\n  if ('undefined' !== typeof window) {\n    window.DS = DS;\n  }\n\n  if (Ember.libraries) {\n    Ember.libraries.registerCoreLibrary('Ember Data', DS.VERSION);\n  }\n}\n\n})();\n//@ sourceURL=ember-data/core");minispade.register('ember-data/ext', "(function() {minispade.require('ember-data/ext/date');\n\n})();\n//@ sourceURL=ember-data/ext");minispade.register('ember-data/ext/date', "(function() {/**\n  @module ember-data\n*/\n\n/**\n  Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n\n  © 2011 Colin Snover <http://zetafleet.com>\n\n  Released under MIT license.\n\n  @class Date\n  @namespace Ember\n  @static\n*/\nEmber.Date = Ember.Date || {};\n\nvar origParse = Date.parse, numericKeys = [ 1, 4, 5, 6, 7, 10, 11 ];\n\n/**\n  @method parse\n  @param date\n*/\nEmber.Date.parse = function (date) {\n    var timestamp, struct, minutesOffset = 0;\n\n    // ES5 §15.9.4.2 states that the string should attempt to be parsed as a Date Time String Format string\n    // before falling back to any implementation-specific date parsing, so that’s what we do, even if native\n    // implementations could be faster\n    //              1 YYYY                2 MM       3 DD           4 HH    5 mm       6 ss        7 msec        8 Z 9 ±    10 tzHH    11 tzmm\n    if ((struct = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/.exec(date))) {\n        // avoid NaN timestamps caused by “undefined” values being passed to Date.UTC\n        for (var i = 0, k; (k = numericKeys[i]); ++i) {\n            struct[k] = +struct[k] || 0;\n        }\n\n        // allow undefined days and months\n        struct[2] = (+struct[2] || 1) - 1;\n        struct[3] = +struct[3] || 1;\n\n        if (struct[8] !== 'Z' && struct[9] !== undefined) {\n            minutesOffset = struct[10] * 60 + struct[11];\n\n            if (struct[9] === '+') {\n                minutesOffset = 0 - minutesOffset;\n            }\n        }\n\n        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);\n    }\n    else {\n        timestamp = origParse ? origParse(date) : NaN;\n    }\n\n    return timestamp;\n};\n\nif (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Date) {\n  Date.parse = Ember.Date.parse;\n}\n\n})();\n//@ sourceURL=ember-data/ext/date");minispade.register('ember-data/initializers', "(function() {minispade.require(\"ember-data/serializers/json_serializer\");\nminispade.require(\"ember-data/system/debug/debug_adapter\");\nminispade.require(\"ember-data/transforms/index\");\n\n/**\n  @module ember-data\n*/\n\nvar set = Ember.set;\n\n/*\n  This code registers an injection for Ember.Application.\n\n  If an Ember.js developer defines a subclass of DS.Store on their application,\n  this code will automatically instantiate it and make it available on the\n  router.\n\n  Additionally, after an application's controllers have been injected, they will\n  each have the store made available to them.\n\n  For example, imagine an Ember.js application with the following classes:\n\n  App.Store = DS.Store.extend({\n    adapter: 'custom'\n  });\n\n  App.PostsController = Ember.ArrayController.extend({\n    // ...\n  });\n\n  When the application is initialized, `App.Store` will automatically be\n  instantiated, and the instance of `App.PostsController` will have its `store`\n  property set to that instance.\n\n  Note that this code will only be run if the `ember-application` package is\n  loaded. If Ember Data is being used in an environment other than a\n  typical application (e.g., node.js where only `ember-runtime` is available),\n  this code will be ignored.\n*/\n\nEmber.onLoad('Ember.Application', function(Application) {\n  Application.initializer({\n    name: \"store\",\n\n    initialize: function(container, application) {\n      application.register('store:main', application.Store || DS.Store);\n      application.register('serializer:_default', DS.JSONSerializer);\n      application.register('serializer:_rest', DS.RESTSerializer);\n      application.register('adapter:_rest', DS.RESTAdapter);\n\n      // Eagerly generate the store so defaultStore is populated.\n      // TODO: Do this in a finisher hook\n      container.lookup('store:main');\n    }\n  });\n\n  Application.initializer({\n    name: \"transforms\",\n    before: \"store\",\n\n    initialize: function(container, application) {\n      application.register('transform:boolean', DS.BooleanTransform);\n      application.register('transform:date', DS.DateTransform);\n      application.register('transform:number', DS.NumberTransform);\n      application.register('transform:string', DS.StringTransform);\n    }\n  });\n\n  Application.initializer({\n    name: \"dataAdapter\",\n    before: \"store\",\n\n    initialize: function(container, application) {\n      application.register('dataAdapter:main', DS.DebugAdapter);\n    }\n  });\n\n  Application.initializer({\n    name: \"injectStore\",\n    before: \"store\",\n\n    initialize: function(container, application) {\n      application.inject('controller', 'store', 'store:main');\n      application.inject('route', 'store', 'store:main');\n      application.inject('serializer', 'store', 'store:main');\n      application.inject('dataAdapter', 'store', 'store:main');\n    }\n  });\n\n});\n\n})();\n//@ sourceURL=ember-data/initializers");minispade.register('ember-data', "(function() {/**\n  Ember Data\n\n  @module ember-data\n  @main ember-data\n*/\nminispade.require(\"ember-data/core\");\nminispade.require(\"ember-data/initializers\");\nminispade.require(\"ember-data/ext\");\nminispade.require(\"ember-data/system/store\");\nminispade.require(\"ember-data/system/model\");\nminispade.require(\"ember-data/system/changes\");\nminispade.require(\"ember-data/system/relationships\");\nminispade.require(\"ember-data/system/record_arrays\");\nminispade.require(\"ember-data/system/record_array_manager\");\nminispade.require(\"ember-data/system/adapter\");\nminispade.require(\"ember-data/adapters\");\nminispade.require(\"ember-data/system/debug\");\n\n})();\n//@ sourceURL=ember-data");minispade.register('ember-data/serializers/json_serializer', "(function() {var get = Ember.get, set = Ember.set, isNone = Ember.isNone;\n\n// Simple dispatcher to support overriding the aliased\n// method in subclasses.\nfunction aliasMethod(methodName) {\n  return function() {\n    return this[methodName].apply(this, arguments);\n  };\n}\n\n/**\n  In Ember Data a Serializer is used to serialize and deserialize\n  records when they are transfered in and out of an external source.\n  This process involves normalizing property names, transforming\n  attribute values and serializeing relationships.\n\n  For maximum performance Ember Data recomends you use the\n  [RESTSerializer](DS.RESTSerializer.html) or one of its subclasses.\n\n  `JSONSerializer` is useful for simpler or legacy backends that may\n  not support the http://jsonapi.org/ spec.\n\n  @class JSONSerializer\n  @namespace DS\n*/\nDS.JSONSerializer = Ember.Object.extend({\n  /**\n    The primaryKey is used when serializing and deserializing\n    data. Ember Data always uses the `id` propery to store the id of\n    the record. The external source may not always follow this\n    convention. In these cases it is usesful to override the\n    primaryKey property to match the primaryKey of your external\n    store.\n\n    Example\n\n    ```javascript\n    App.ApplicationSerializer = DS.JSONSerializer.extend({\n      primaryKey: '_id'\n    });\n    ```\n\n    @property primaryKey\n    @type {String}\n  */\n  primaryKey: 'id',\n\n  /**\n   Given a subclass of `DS.Model` and a JSON object this method will\n   iterate through each attribute of the `DS.Model` and invoke the\n   `DS.Transform#deserialize` method on the matching property of the\n   JSON object.  This method is typically called after the\n   serializer's `normalize` method.\n\n   @method applyTransforms\n   @private\n   @param {subclass of DS.Model} type\n   @param {Object} data The data to transform\n   @return {Object} data The transformed data object\n  */\n  applyTransforms: function(type, data) {\n    type.eachTransformedAttribute(function(key, type) {\n      var transform = this.transformFor(type);\n      data[key] = transform.deserialize(data[key]);\n    }, this);\n\n    return data;\n  },\n\n  /**\n    Normalizes a part of the JSON payload returned by\n    the server. You should override this method, munge the hash\n    and call super if you have generic normalization to do.\n\n    It takes the type of the record that is being normalized\n    (as a DS.Model class), the property where the hash was\n    originally found, and the hash to normalize.\n\n    You can use this method, for example, to normalize underscored keys to camelized\n    or other general-purpose normalizations.\n\n    Example\n\n    ```javascript\n    App.ApplicationSerializer = DS.JSONSerializer.extend({\n      normalize: function(type, hash) {\n        var normalizedHash = {};\n        var fields = Ember.get(type, 'fields');\n        fields.forEach(function(field) {\n          var normalizedProp = Ember.String.camelize(field);\n          normalizedHash[normalizedProp] = hash[field];\n        });\n        return this._super.apply(this, arguments);\n      }\n    });\n    ```\n\n    @method normalize\n    @param {subclass of DS.Model} type\n    @param {Object} hash\n    @return {Object}\n  */\n  normalize: function(type, hash) {\n    if (!hash) { return hash; }\n\n    this.applyTransforms(type, hash);\n    return hash;\n  },\n\n  // SERIALIZE\n  /**\n    Called when a record is saved in order to convert the\n    record into JSON.\n\n    By default, it creates a JSON object with a key for\n    each attribute and belongsTo relationship.\n\n    For example, consider this model:\n\n    ```javascript\n    App.Comment = DS.Model.extend({\n      title: DS.attr(),\n      body: DS.attr(),\n\n      author: DS.belongsTo('user')\n    });\n    ```\n\n    The default serialization would create a JSON object like:\n\n    ```javascript\n    {\n      \"title\": \"Rails is unagi\",\n      \"body\": \"Rails? Omakase? O_O\",\n      \"author\": 12\n    }\n    ```\n\n    By default, attributes are passed through as-is, unless\n    you specified an attribute type (`DS.attr('date')`). If\n    you specify a transform, the JavaScript value will be\n    serialized when inserted into the JSON hash.\n\n    By default, belongs-to relationships are converted into\n    IDs when inserted into the JSON hash.\n\n    ## IDs\n\n    `serialize` takes an options hash with a single option:\n    `includeId`. If this option is `true`, `serialize` will,\n    by default include the ID in the JSON object it builds.\n\n    The adapter passes in `includeId: true` when serializing\n    a record for `createRecord`, but not for `updateRecord`.\n\n    ## Customization\n\n    Your server may expect a different JSON format than the\n    built-in serialization format.\n\n    In that case, you can implement `serialize` yourself and\n    return a JSON hash of your choosing.\n\n    ```javascript\n    App.PostSerializer = DS.JSONSerializer.extend({\n      serialize: function(post, options) {\n        var json = {\n          POST_TTL: post.get('title'),\n          POST_BDY: post.get('body'),\n          POST_CMS: post.get('comments').mapProperty('id')\n        }\n\n        if (options.includeId) {\n          json.POST_ID_ = post.get('id');\n        }\n\n        return json;\n      }\n    });\n    ```\n\n    ## Customizing an App-Wide Serializer\n\n    If you want to define a serializer for your entire\n    application, you'll probably want to use `eachAttribute`\n    and `eachRelationship` on the record.\n\n    ```javascript\n    App.ApplicationSerializer = DS.JSONSerializer.extend({\n      serialize: function(record, options) {\n        var json = {};\n\n        record.eachAttribute(function(name) {\n          json[serverAttributeName(name)] = record.get(name);\n        })\n\n        record.eachRelationship(function(name, relationship) {\n          if (relationship.kind === 'hasMany') {\n            json[serverHasManyName(name)] = record.get(name).mapBy('id');\n          }\n        });\n\n        if (options.includeId) {\n          json.ID_ = record.get('id');\n        }\n\n        return json;\n      }\n    });\n\n    function serverAttributeName(attribute) {\n      return attribute.underscore().toUpperCase();\n    }\n\n    function serverHasManyName(name) {\n      return serverAttributeName(name.singularize()) + \"_IDS\";\n    }\n    ```\n\n    This serializer will generate JSON that looks like this:\n\n    ```javascript\n    {\n      \"TITLE\": \"Rails is omakase\",\n      \"BODY\": \"Yep. Omakase.\",\n      \"COMMENT_IDS\": [ 1, 2, 3 ]\n    }\n    ```\n\n    ## Tweaking the Default JSON\n\n    If you just want to do some small tweaks on the default JSON,\n    you can call super first and make the tweaks on the returned\n    JSON.\n\n    ```javascript\n    App.PostSerializer = DS.JSONSerializer.extend({\n      serialize: function(record, options) {\n        var json = this._super.apply(this, arguments);\n\n        json.subject = json.title;\n        delete json.title;\n\n        return json;\n      }\n    });\n    ```\n\n    @method serialize\n    @param {subclass of DS.Model} record\n    @param {Object} options\n    @return {Object} json\n  */\n  serialize: function(record, options) {\n    var json = {};\n\n    if (options && options.includeId) {\n      var id = get(record, 'id');\n\n      if (id) {\n        json[get(this, 'primaryKey')] = get(record, 'id');\n      }\n    }\n\n    record.eachAttribute(function(key, attribute) {\n      this.serializeAttribute(record, json, key, attribute);\n    }, this);\n\n    record.eachRelationship(function(key, relationship) {\n      if (relationship.kind === 'belongsTo') {\n        this.serializeBelongsTo(record, json, relationship);\n      } else if (relationship.kind === 'hasMany') {\n        this.serializeHasMany(record, json, relationship);\n      }\n    }, this);\n\n    return json;\n  },\n\n  /**\n   `serializeAttribute` can be used to customize how `DS.attr`\n   properties are serialized\n\n   For example if you wanted to ensure all you attributes were always\n   serialized as properties on an `attributes` object you could\n   write:\n\n   ```javascript\n   App.ApplicationSerializer = DS.JSONSerializer.extend({\n     serializeAttribute: function(record, json, key, attributes) {\n       json.attributes = json.attributes || {};\n       this._super(record, json.attributes, key, attributes);\n     }\n   });\n   ```\n\n   @method serializeAttribute\n   @param {DS.Model} record\n   @param {Object} json\n   @param {String} key\n   @param {Object} attribute\n  */\n  serializeAttribute: function(record, json, key, attribute) {\n    var attrs = get(this, 'attrs');\n    var value = get(record, key), type = attribute.type;\n\n    if (type) {\n      var transform = this.transformFor(type);\n      value = transform.serialize(value);\n    }\n\n    // if provided, use the mapping provided by `attrs` in\n    // the serializer\n    key = attrs && attrs[key] || (this.keyForAttribute ? this.keyForAttribute(key) : key);\n\n    json[key] = value;\n  },\n\n  /**\n   `serializeBelongsTo` can be used to customize how `DS.belongsTo`\n   properties are serialized.\n\n   Example\n\n   ```javascript\n   App.PostSerializer = DS.JSONSerializer.extend({\n     serializeBelongsTo: function(record, json, relationship) {\n       var key = relationship.key;\n\n       var belongsTo = get(record, key);\n\n       key = this.keyForRelationship ? this.keyForRelationship(key, \"belongsTo\") : key;\n\n       json[key] = Ember.isNone(belongsTo) ? belongsTo : belongsTo.toJSON();\n     }\n   });\n   ```\n\n   @method serializeBelongsTo\n   @param {DS.Model} record\n   @param {Object} json\n   @param {Object} relationship\n  */\n  serializeBelongsTo: function(record, json, relationship) {\n    var key = relationship.key;\n\n    var belongsTo = get(record, key);\n\n    key = this.keyForRelationship ? this.keyForRelationship(key, \"belongsTo\") : key;\n\n    if (isNone(belongsTo)) {\n      json[key] = belongsTo;\n    } else {\n      json[key] = get(belongsTo, 'id');\n    }\n\n    if (relationship.options.polymorphic) {\n      this.serializePolymorphicType(record, json, relationship);\n    }\n  },\n\n  /**\n   `serializeHasMany` can be used to customize how `DS.hasMany`\n   properties are serialized.\n\n   Example\n\n   ```javascript\n   App.PostSerializer = DS.JSONSerializer.extend({\n     serializeHasMany: function(record, json, relationship) {\n       var key = relationship.key;\n       if (key === 'comments') {\n         return;\n       } else {\n         this._super.apply(this, arguments);\n       }\n     }\n   });\n   ```\n\n   @method serializeHasMany\n   @param {DS.Model} record\n   @param {Object} json\n   @param {Object} relationship\n  */\n  serializeHasMany: function(record, json, relationship) {\n    var key = relationship.key;\n\n    var relationshipType = DS.RelationshipChange.determineRelationshipType(record.constructor, relationship);\n\n    if (relationshipType === 'manyToNone' || relationshipType === 'manyToMany') {\n      json[key] = get(record, key).mapBy('id');\n      // TODO support for polymorphic manyToNone and manyToMany relationships\n    }\n  },\n\n  /**\n    You can use this method to customize how polymorphic objects are\n    serialized. Objects are considered to be polymorphic if\n    `{polymorphic: true}` is pass as the second argument to the\n    `DS.belongsTo` function.\n\n    Example\n\n    ```javascript\n    App.CommentSerializer = DS.JSONSerializer.extend({\n      serializePolymorphicType: function(record, json, relationship) {\n        var key = relationship.key,\n            belongsTo = get(record, key);\n        key = this.keyForAttribute ? this.keyForAttribute(key) : key;\n        json[key + \"_type\"] = belongsTo.constructor.typeKey;\n      }\n    });\n   ```\n\n    @method serializePolymorphicType\n    @param {DS.Model} record\n    @param {Object} json\n    @param {Object} relationship\n  */\n  serializePolymorphicType: Ember.K,\n\n  // EXTRACT\n\n  /**\n    The `extract` method is used to deserialize payload data from the\n    server. By default the `JSONSerializer` does not push the records\n    into the store. However records that subclass `JSONSerializer`\n    such as the `RESTSerializer` may push records into the store as\n    part of the extract call.\n\n    This method deletegates to a more specific extract method based on\n    the `requestType`.\n\n    Example\n\n    ```javascript\n    var get = Ember.get;\n    socket.on('message', function(message) {\n      var modelName = message.model;\n      var data = message.data;\n      var type = store.modelFor(modelName);\n      var serializer = store.serializerFor(type.typeKey);\n      var record = serializer.extract(store, type, data, get(data, 'id'), 'single');\n      store.push(modelName, record);\n    });\n    ```\n\n    @method extract\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @param {String or Number} id\n    @param {String} requestType\n    @return {Object} json The deserialized payload\n  */\n  extract: function(store, type, payload, id, requestType) {\n    this.extractMeta(store, type, payload);\n\n    var specificExtract = \"extract\" + requestType.charAt(0).toUpperCase() + requestType.substr(1);\n    return this[specificExtract](store, type, payload, id, requestType);\n  },\n\n  /**\n    `extractFindAll` is a hook into the extract method used when a\n    call is made to `DS.Store#findAll`. By default this method is an\n    alias for [extractArray](#method_extractArray).\n\n    @method extractFindAll\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Array} array An array of deserialized objects\n  */\n  extractFindAll: aliasMethod('extractArray'),\n  /**\n    `extractFindQuery` is a hook into the extract method used when a\n    call is made to `DS.Store#findQuery`. By default this method is an\n    alias for [extractArray](#method_extractArray).\n\n    @method extractFindQuery\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Array} array An array of deserialized objects\n  */\n  extractFindQuery: aliasMethod('extractArray'),\n  /**\n    `extractFindMany` is a hook into the extract method used when a\n    call is made to `DS.Store#findMany`. By default this method is\n    alias for [extractArray](#method_extractArray).\n\n    @method extractFindMany\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Array} array An array of deserialized objects\n  */\n  extractFindMany: aliasMethod('extractArray'),\n  /**\n    `extractFindHasMany` is a hook into the extract method used when a\n    call is made to `DS.Store#findHasMany`. By default this method is\n    alias for [extractArray](#method_extractArray).\n\n    @method extractFindHasMany\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Array} array An array of deserialized objects\n  */\n  extractFindHasMany: aliasMethod('extractArray'),\n\n  /**\n    `extractCreateRecord` is a hook into the extract method used when a\n    call is made to `DS.Store#createRecord`. By default this method is\n    alias for [extractSave](#method_extractSave).\n\n    @method extractCreateRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Object} json The deserialized payload\n  */\n  extractCreateRecord: aliasMethod('extractSave'),\n  /**\n    `extractUpdateRecord` is a hook into the extract method used when\n    a call is made to `DS.Store#update`. By default this method is alias\n    for [extractSave](#method_extractSave).\n\n    @method extractUpdateRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Object} json The deserialized payload\n  */\n  extractUpdateRecord: aliasMethod('extractSave'),\n  /**\n    `extractDeleteRecord` is a hook into the extract method used when\n    a call is made to `DS.Store#deleteRecord`. By default this method is\n    alias for [extractSave](#method_extractSave).\n\n    @method extractDeleteRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Object} json The deserialized payload\n  */\n  extractDeleteRecord: aliasMethod('extractSave'),\n\n  /**\n    `extractFind` is a hook into the extract method used when\n    a call is made to `DS.Store#find`. By default this method is\n    alias for [extractSingle](#method_extractSingle).\n\n    @method extractFind\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Object} json The deserialized payload\n  */\n  extractFind: aliasMethod('extractSingle'),\n  /**\n    `extractFindBelongsTo` is a hook into the extract method used when\n    a call is made to `DS.Store#findBelongsTo`. By default this method is\n    alias for [extractSingle](#method_extractSingle).\n\n    @method extractFindBelongsTo\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Object} json The deserialized payload\n  */\n  extractFindBelongsTo: aliasMethod('extractSingle'),\n  /**\n    `extractSave` is a hook into the extract method used when a call\n    is made to `DS.Model#save`. By default this method is alias\n    for [extractSingle](#method_extractSingle).\n\n    @method extractSave\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Object} json The deserialized payload\n  */\n  extractSave: aliasMethod('extractSingle'),\n\n  /**\n    `extractSingle` is used to deserialize a single record returned\n    from the adapter.\n\n    Example\n\n    ```javascript\n    App.PostSerializer = DS.JSONSerializer.extend({\n      extractSingle: function(store, type, payload) {\n        payload.comments = payload._embedded.comment;\n        delete payload._embedded;\n\n        return this._super(store, type, payload);\n      },\n    });\n    ```\n\n    @method extractSingle\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Object} json The deserialized payload\n  */\n  extractSingle: function(store, type, payload) {\n    return this.normalize(type, payload);\n  },\n\n  /**\n    `extractArray` is used to deserialize an array of records\n    returned from the adapter.\n\n    Example\n\n    ```javascript\n    App.PostSerializer = DS.JSONSerializer.extend({\n      extractArray: function(store, type, payload) {\n        return payload.map(function(json) {\n          return this.extractSingle(json);\n        }, this);\n      }\n    });\n    ```\n\n    @method extractArray\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @return {Array} array An array of deserialized objects\n  */\n  extractArray: function(store, type, payload) {\n    return this.normalize(type, payload);\n  },\n\n  /**\n    `extractMeta` is used to deserialize any meta information in the\n    adapter payload. By default Ember Data expects meta information to\n    be located on the `meta` property of the payload object.\n\n    Example\n\n    ```javascript\n    App.PostSerializer = DS.JSONSerializer.extend({\n      extractMeta: function(store, type, payload) {\n        if (payload && payload._pagination) {\n          store.metaForType(type, payload._pagination);\n          delete payload._pagination;\n        }\n      }\n    });\n    ```\n\n    @method extractMeta\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n  */\n  extractMeta: function(store, type, payload) {\n    if (payload && payload.meta) {\n      store.metaForType(type, payload.meta);\n      delete payload.meta;\n    }\n  },\n\n  /**\n   `keyForRelationship` can be used to define a custom key when\n   serializeing relationship properties. By default `JSONSerializer`\n   does not provide an implementation of this method.\n\n   Example\n\n    ```javascript\n    App.PostSerializer = DS.JSONSerializer.extend({\n      keyForRelationship: function(key, relationship) {\n         return 'rel_' + Ember.String.underscore(key);\n      }\n    });\n    ```\n\n   @method keyForRelationship\n   @param {String} key\n   @param {String} relationship type\n   @return {String} normalized key\n  */\n\n  // HELPERS\n\n  /**\n   @method transformFor\n   @private\n   @param {String} attributeType\n   @param {Boolean} skipAssertion\n   @return {DS.Transform} transform\n  */\n  transformFor: function(attributeType, skipAssertion) {\n    var transform = this.container.lookup('transform:' + attributeType);\n    Ember.assert(\"Unable to find transform for '\" + attributeType + \"'\", skipAssertion || !!transform);\n    return transform;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/serializers/json_serializer");minispade.register('ember-data/serializers/rest_serializer', "(function() {minispade.require('ember-data/serializers/json_serializer');\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.ArrayPolyfills.forEach;\nvar map = Ember.ArrayPolyfills.map;\n\nfunction coerceId(id) {\n  return id == null ? null : id+'';\n}\n\n/**\n  Normally, applications will use the `RESTSerializer` by implementing\n  the `normalize` method and individual normalizations under\n  `normalizeHash`.\n\n  This allows you to do whatever kind of munging you need, and is\n  especially useful if your server is inconsistent and you need to\n  do munging differently for many different kinds of responses.\n\n  See the `normalize` documentation for more information.\n\n  ## Across the Board Normalization\n\n  There are also a number of hooks that you might find useful to defined\n  across-the-board rules for your payload. These rules will be useful\n  if your server is consistent, or if you're building an adapter for\n  an infrastructure service, like Parse, and want to encode service\n  conventions.\n\n  For example, if all of your keys are underscored and all-caps, but\n  otherwise consistent with the names you use in your models, you\n  can implement across-the-board rules for how to convert an attribute\n  name in your model to a key in your JSON.\n\n  ```js\n  App.ApplicationSerializer = DS.RESTSerializer.extend({\n    keyForAttribute: function(attr) {\n      return Ember.String.underscore(attr).toUpperCase();\n    }\n  });\n  ```\n\n  You can also implement `keyForRelationship`, which takes the name\n  of the relationship as the first parameter, and the kind of\n  relationship (`hasMany` or `belongsTo`) as the second parameter.\n\n  @class RESTSerializer\n  @namespace DS\n  @extends DS.JSONSerializer\n*/\nDS.RESTSerializer = DS.JSONSerializer.extend({\n  /**\n    Normalizes a part of the JSON payload returned by\n    the server. You should override this method, munge the hash\n    and call super if you have generic normalization to do.\n\n    It takes the type of the record that is being normalized\n    (as a DS.Model class), the property where the hash was\n    originally found, and the hash to normalize.\n\n    For example, if you have a payload that looks like this:\n\n    ```js\n    {\n      \"post\": {\n        \"id\": 1,\n        \"title\": \"Rails is omakase\",\n        \"comments\": [ 1, 2 ]\n      },\n      \"comments\": [{\n        \"id\": 1,\n        \"body\": \"FIRST\"\n      }, {\n        \"id\": 2,\n        \"body\": \"Rails is unagi\"\n      }]\n    }\n    ```\n\n    The `normalize` method will be called three times:\n\n    * With `App.Post`, `\"posts\"` and `{ id: 1, title: \"Rails is omakase\", ... }`\n    * With `App.Comment`, `\"comments\"` and `{ id: 1, body: \"FIRST\" }`\n    * With `App.Comment`, `\"comments\"` and `{ id: 2, body: \"Rails is unagi\" }`\n\n    You can use this method, for example, to normalize underscored keys to camelized\n    or other general-purpose normalizations.\n\n    If you want to do normalizations specific to some part of the payload, you\n    can specify those under `normalizeHash`.\n\n    For example, if the `IDs` under `\"comments\"` are provided as `_id` instead of\n    `id`, you can specify how to normalize just the comments:\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      normalizeHash: {\n        comments: function(hash) {\n          hash.id = hash._id;\n          delete hash._id;\n          return hash;\n        }\n      }\n    });\n    ```\n\n    The key under `normalizeHash` is just the original key that was in the original\n    payload.\n\n    @method normalize\n    @param {subclass of DS.Model} type\n    @param {Object} hash\n    @param {String} prop\n    @returns {Object}\n  */\n  normalize: function(type, hash, prop) {\n    this.normalizeId(hash);\n    this.normalizeAttributes(type, hash);\n    this.normalizeRelationships(type, hash);\n\n    this.normalizeUsingDeclaredMapping(type, hash);\n\n    if (this.normalizeHash && this.normalizeHash[prop]) {\n      this.normalizeHash[prop](hash);\n    }\n\n    return this._super(type, hash, prop);\n  },\n\n  /**\n    You can use this method to normalize all payloads, regardless of whether they\n    represent single records or an array.\n\n    For example, you might want to remove some extraneous data from the payload:\n\n    ```js\n    App.ApplicationSerializer = DS.RESTSerializer.extend({\n      normalizePayload: function(type, payload) {\n        delete payload.version;\n        delete payload.status;\n        return payload;\n      }\n    });\n    ```\n\n    @method normalizePayload\n    @param {subclass of DS.Model} type\n    @param {Object} hash\n    @returns {Object} the normalized payload\n  */\n  normalizePayload: function(type, payload) {\n    return payload;\n  },\n\n  /**\n    @method normalizeId\n    @private\n  */\n  normalizeId: function(hash) {\n    var primaryKey = get(this, 'primaryKey');\n\n    if (primaryKey === 'id') { return; }\n\n    hash.id = hash[primaryKey];\n    delete hash[primaryKey];\n  },\n\n  /**\n    @method normalizeUsingDeclaredMapping\n    @private\n  */\n  normalizeUsingDeclaredMapping: function(type, hash) {\n    var attrs = get(this, 'attrs'), payloadKey, key;\n\n    if (attrs) {\n      for (key in attrs) {\n        payloadKey = attrs[key];\n        if (payloadKey && payloadKey.key) {\n          payloadKey = payloadKey.key;\n        }\n        if (typeof payloadKey === 'string') {\n          hash[key] = hash[payloadKey];\n          delete hash[payloadKey];\n        }\n      }\n    }\n  },\n\n  /**\n    @method normalizeAttributes\n    @private\n  */\n  normalizeAttributes: function(type, hash) {\n    var payloadKey, key;\n\n    if (this.keyForAttribute) {\n      type.eachAttribute(function(key) {\n        payloadKey = this.keyForAttribute(key);\n        if (key === payloadKey) { return; }\n\n        hash[key] = hash[payloadKey];\n        delete hash[payloadKey];\n      }, this);\n    }\n  },\n\n  /**\n    @method normalizeRelationships\n    @private\n  */\n  normalizeRelationships: function(type, hash) {\n    var payloadKey, key;\n\n    if (this.keyForRelationship) {\n      type.eachRelationship(function(key, relationship) {\n        payloadKey = this.keyForRelationship(key, relationship.kind);\n        if (key === payloadKey) { return; }\n\n        hash[key] = hash[payloadKey];\n        delete hash[payloadKey];\n      }, this);\n    }\n  },\n\n  /**\n    Called when the server has returned a payload representing\n    a single record, such as in response to a `find` or `save`.\n\n    It is your opportunity to clean up the server's response into the normalized\n    form expected by Ember Data.\n\n    If you want, you can just restructure the top-level of your payload, and\n    do more fine-grained normalization in the `normalize` method.\n\n    For example, if you have a payload like this in response to a request for\n    post 1:\n\n    ```js\n    {\n      \"id\": 1,\n      \"title\": \"Rails is omakase\",\n\n      \"_embedded\": {\n        \"comment\": [{\n          \"_id\": 1,\n          \"comment_title\": \"FIRST\"\n        }, {\n          \"_id\": 2,\n          \"comment_title\": \"Rails is unagi\"\n        }]\n      }\n    }\n    ```\n\n    You could implement a serializer that looks like this to get your payload\n    into shape:\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      // First, restructure the top-level so it's organized by type\n      extractSingle: function(store, type, payload, id, requestType) {\n        var comments = payload._embedded.comment;\n        delete payload._embedded;\n\n        payload = { comments: comments, post: payload };\n        return this._super(store, type, payload, id, requestType);\n      },\n\n      normalizeHash: {\n        // Next, normalize individual comments, which (after `extract`)\n        // are now located under `comments`\n        comments: function(hash) {\n          hash.id = hash._id;\n          hash.title = hash.comment_title;\n          delete hash._id;\n          delete hash.comment_title;\n          return hash;\n        }\n      }\n    })\n    ```\n\n    When you call super from your own implementation of `extractSingle`, the\n    built-in implementation will find the primary record in your normalized\n    payload and push the remaining records into the store.\n\n    The primary record is the single hash found under `post` or the first\n    element of the `posts` array.\n\n    The primary record has special meaning when the record is being created\n    for the first time or updated (`createRecord` or `updateRecord`). In\n    particular, it will update the properties of the record that was saved.\n\n    @method extractSingle\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @param {String} id\n    @param {'find'|'createRecord'|'updateRecord'|'deleteRecord'} requestType\n    @returns {Object} the primary response to the original request\n  */\n  extractSingle: function(store, primaryType, payload, recordId, requestType) {\n    payload = this.normalizePayload(primaryType, payload);\n\n    var primaryTypeName = primaryType.typeKey,\n        primaryRecord;\n\n    for (var prop in payload) {\n      var typeName  = this.typeForRoot(prop),\n          isPrimary = typeName === primaryTypeName;\n\n      // legacy support for singular resources\n      if (isPrimary && Ember.typeOf(payload[prop]) !== \"array\" ) {\n        primaryRecord = this.normalize(primaryType, payload[prop], prop);\n        continue;\n      }\n\n      var type = store.modelFor(typeName);\n\n      /*jshint loopfunc:true*/\n      forEach.call(payload[prop], function(hash) {\n        var typeName = this.typeForRoot(prop),\n            type = store.modelFor(typeName),\n            typeSerializer = store.serializerFor(type);\n\n        hash = typeSerializer.normalize(type, hash, prop);\n\n        var isFirstCreatedRecord = isPrimary && !recordId && !primaryRecord,\n            isUpdatedRecord = isPrimary && coerceId(hash.id) === recordId;\n\n        // find the primary record.\n        //\n        // It's either:\n        // * the record with the same ID as the original request\n        // * in the case of a newly created record that didn't have an ID, the first\n        //   record in the Array\n        if (isFirstCreatedRecord || isUpdatedRecord) {\n          primaryRecord = hash;\n        } else {\n          store.push(typeName, hash);\n        }\n      }, this);\n    }\n\n    return primaryRecord;\n  },\n\n  /**\n    Called when the server has returned a payload representing\n    multiple records, such as in response to a `findAll` or `findQuery`.\n\n    It is your opportunity to clean up the server's response into the normalized\n    form expected by Ember Data.\n\n    If you want, you can just restructure the top-level of your payload, and\n    do more fine-grained normalization in the `normalize` method.\n\n    For example, if you have a payload like this in response to a request for\n    all posts:\n\n    ```js\n    {\n      \"_embedded\": {\n        \"post\": [{\n          \"id\": 1,\n          \"title\": \"Rails is omakase\"\n        }, {\n          \"id\": 2,\n          \"title\": \"The Parley Letter\"\n        }],\n        \"comment\": [{\n          \"_id\": 1,\n          \"comment_title\": \"Rails is unagi\"\n          \"post_id\": 1\n        }, {\n          \"_id\": 2,\n          \"comment_title\": \"Don't tread on me\",\n          \"post_id\": 2\n        }]\n      }\n    }\n    ```\n\n    You could implement a serializer that looks like this to get your payload\n    into shape:\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      // First, restructure the top-level so it's organized by type\n      // and the comments are listed under a post's `comments` key.\n      extractArray: function(store, type, payload, id, requestType) {\n        var posts = payload._embedded.post;\n        var comments = [];\n        var postCache = {};\n\n        posts.forEach(function(post) {\n          post.comments = [];\n          postCache[post.id] = post;\n        });\n\n        payload._embedded.comment.forEach(function(comment) {\n          comments.push(comment);\n          postCache[comment.post_id].comments.push(comment);\n          delete comment.post_id;\n        }\n\n        payload = { comments: comments, posts: payload };\n\n        return this._super(store, type, payload, id, requestType);\n      },\n\n      normalizeHash: {\n        // Next, normalize individual comments, which (after `extract`)\n        // are now located under `comments`\n        comments: function(hash) {\n          hash.id = hash._id;\n          hash.title = hash.comment_title;\n          delete hash._id;\n          delete hash.comment_title;\n          return hash;\n        }\n      }\n    })\n    ```\n\n    When you call super from your own implementation of `extractArray`, the\n    built-in implementation will find the primary array in your normalized\n    payload and push the remaining records into the store.\n\n    The primary array is the array found under `posts`.\n\n    The primary record has special meaning when responding to `findQuery`\n    or `findHasMany`. In particular, the primary array will become the\n    list of records in the record array that kicked off the request.\n\n    If your primary array contains secondary (embedded) records of the same type,\n    you cannot place these into the primary array `posts`. Instead, place the\n    secondary items into an underscore prefixed property `_posts`, which will\n    push these items into the store and will not affect the resulting query.\n\n    @method extractArray\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @param {'findAll'|'findMany'|'findHasMany'|'findQuery'} requestType\n    @returns {Array} The primary array that was returned in response\n      to the original query.\n  */\n  extractArray: function(store, primaryType, payload) {\n    payload = this.normalizePayload(primaryType, payload);\n\n    var primaryTypeName = primaryType.typeKey,\n        primaryArray;\n\n    for (var prop in payload) {\n      var typeKey = prop,\n          forcedSecondary = false;\n\n      if (prop.charAt(0) === '_') {\n        forcedSecondary = true;\n        typeKey = prop.substr(1);\n      }\n\n      var typeName = this.typeForRoot(typeKey),\n          type = store.modelFor(typeName),\n          typeSerializer = store.serializerFor(type),\n          isPrimary = (!forcedSecondary && (typeName === primaryTypeName));\n\n      /*jshint loopfunc:true*/\n      var normalizedArray = map.call(payload[prop], function(hash) {\n        return typeSerializer.normalize(type, hash, prop);\n      }, this);\n\n      if (isPrimary) {\n        primaryArray = normalizedArray;\n      } else {\n        store.pushMany(typeName, normalizedArray);\n      }\n    }\n\n    return primaryArray;\n  },\n\n  /**\n    This method allows you to push a payload containing top-level\n    collections of records organized per type.\n\n    ```js\n    {\n      \"posts\": [{\n        \"id\": \"1\",\n        \"title\": \"Rails is omakase\",\n        \"author\", \"1\",\n        \"comments\": [ \"1\" ]\n      }],\n      \"comments\": [{\n        \"id\": \"1\",\n        \"body\": \"FIRST\"\n      }],\n      \"users\": [{\n        \"id\": \"1\",\n        \"name\": \"@d2h\"\n      }]\n    }\n    ```\n\n    It will first normalize the payload, so you can use this to push\n    in data streaming in from your server structured the same way\n    that fetches and saves are structured.\n\n    @method pushPayload\n    @param {DS.Store} store\n    @param {Object} payload\n  */\n  pushPayload: function(store, payload) {\n    payload = this.normalizePayload(null, payload);\n\n    for (var prop in payload) {\n      var typeName = this.typeForRoot(prop),\n          type = store.modelFor(typeName);\n\n      /*jshint loopfunc:true*/\n      var normalizedArray = map.call(payload[prop], function(hash) {\n        return this.normalize(type, hash, prop);\n      }, this);\n\n      store.pushMany(typeName, normalizedArray);\n    }\n  },\n\n  /**\n    You can use this method to normalize the JSON root keys returned\n    into the model type expected by your store.\n\n    For example, your server may return underscored root keys rather than\n    the expected camelcased versions.\n\n    ```js\n    App.ApplicationSerializer = DS.RESTSerializer.extend({\n      typeForRoot: function(root) {\n        var camelized = Ember.String.camelize(root);\n        return Ember.String.singularize(camelized);\n      }\n    });\n    ```\n\n    @method typeForRoot\n    @param {String} root\n    @returns {String} the model's typeKey\n  */\n  typeForRoot: function(root) {\n    return Ember.String.singularize(root);\n  },\n\n  // SERIALIZE\n\n  /**\n    Called when a record is saved in order to convert the\n    record into JSON.\n\n    By default, it creates a JSON object with a key for\n    each attribute and belongsTo relationship.\n\n    For example, consider this model:\n\n    ```js\n    App.Comment = DS.Model.extend({\n      title: DS.attr(),\n      body: DS.attr(),\n\n      author: DS.belongsTo('user')\n    });\n    ```\n\n    The default serialization would create a JSON object like:\n\n    ```js\n    {\n      \"title\": \"Rails is unagi\",\n      \"body\": \"Rails? Omakase? O_O\",\n      \"author\": 12\n    }\n    ```\n\n    By default, attributes are passed through as-is, unless\n    you specified an attribute type (`DS.attr('date')`). If\n    you specify a transform, the JavaScript value will be\n    serialized when inserted into the JSON hash.\n\n    By default, belongs-to relationships are converted into\n    IDs when inserted into the JSON hash.\n\n    ## IDs\n\n    `serialize` takes an options hash with a single option:\n    `includeId`. If this option is `true`, `serialize` will,\n    by default include the ID in the JSON object it builds.\n\n    The adapter passes in `includeId: true` when serializing\n    a record for `createRecord`, but not for `updateRecord`.\n\n    ## Customization\n\n    Your server may expect a different JSON format than the\n    built-in serialization format.\n\n    In that case, you can implement `serialize` yourself and\n    return a JSON hash of your choosing.\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      serialize: function(post, options) {\n        var json = {\n          POST_TTL: post.get('title'),\n          POST_BDY: post.get('body'),\n          POST_CMS: post.get('comments').mapProperty('id')\n        }\n\n        if (options.includeId) {\n          json.POST_ID_ = post.get('id');\n        }\n\n        return json;\n      }\n    });\n    ```\n\n    ## Customizing an App-Wide Serializer\n\n    If you want to define a serializer for your entire\n    application, you'll probably want to use `eachAttribute`\n    and `eachRelationship` on the record.\n\n    ```js\n    App.ApplicationSerializer = DS.RESTSerializer.extend({\n      serialize: function(record, options) {\n        var json = {};\n\n        record.eachAttribute(function(name) {\n          json[serverAttributeName(name)] = record.get(name);\n        })\n\n        record.eachRelationship(function(name, relationship) {\n          if (relationship.kind === 'hasMany') {\n            json[serverHasManyName(name)] = record.get(name).mapBy('id');\n          }\n        });\n\n        if (options.includeId) {\n          json.ID_ = record.get('id');\n        }\n\n        return json;\n      }\n    });\n\n    function serverAttributeName(attribute) {\n      return attribute.underscore().toUpperCase();\n    }\n\n    function serverHasManyName(name) {\n      return serverAttributeName(name.singularize()) + \"_IDS\";\n    }\n    ```\n\n    This serializer will generate JSON that looks like this:\n\n    ```js\n    {\n      \"TITLE\": \"Rails is omakase\",\n      \"BODY\": \"Yep. Omakase.\",\n      \"COMMENT_IDS\": [ 1, 2, 3 ]\n    }\n    ```\n\n    ## Tweaking the Default JSON\n\n    If you just want to do some small tweaks on the default JSON,\n    you can call super first and make the tweaks on the returned\n    JSON.\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      serialize: function(record, options) {\n        var json = this._super(record, options);\n\n        json.subject = json.title;\n        delete json.title;\n\n        return json;\n      }\n    });\n    ```\n\n    @method serialize\n    @param record\n    @param options\n  */\n  serialize: function(record, options) {\n    return this._super.apply(this, arguments);\n  },\n\n  /**\n    You can use this method to customize the root keys serialized into the JSON.\n    By default the REST Serializer sends camelized root keys.\n    For example, your server may expect underscored root objects.\n\n    ```js\n    App.ApplicationSerializer = DS.RESTSerializer.extend({\n      serializeIntoHash: function(data, type, record, options) {\n        var root = Ember.String.decamelize(type.typeKey);\n        data[root] = this.serialize(record, options);\n      }\n    });\n    ```\n\n    @method serializeIntoHash\n    @param {Object} hash\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @param {Object} options\n  */\n  serializeIntoHash: function(hash, type, record, options) {\n    hash[type.typeKey] = this.serialize(record, options);\n  },\n\n  /**\n    You can use this method to customize how polymorphic objects are serialized.\n    By default the JSON Serializer creates the key by appending `Type` to\n    the attribute and value from the model's camelcased model name.\n\n    @method serializePolymorphicType\n    @param {DS.Model} record\n    @param {Object} json\n    @param {Object} relationship\n  */\n  serializePolymorphicType: function(record, json, relationship) {\n    var key = relationship.key,\n        belongsTo = get(record, key);\n    key = this.keyForAttribute ? this.keyForAttribute(key) : key;\n    json[key + \"Type\"] = belongsTo.constructor.typeKey;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/serializers/rest_serializer");minispade.register('ember-data/system/adapter', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar map = Ember.ArrayPolyfills.map;\n\nvar errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\nDS.InvalidError = function(errors) {\n  var tmp = Error.prototype.constructor.call(this, \"The backend rejected the commit because it was invalid: \" + Ember.inspect(errors));\n  this.errors = errors;\n\n  for (var i=0, l=errorProps.length; i<l; i++) {\n    this[errorProps[i]] = tmp[errorProps[i]];\n  }\n};\nDS.InvalidError.prototype = Ember.create(Error.prototype);\n\n/**\n  An adapter is an object that receives requests from a store and\n  translates them into the appropriate action to take against your\n  persistence layer. The persistence layer is usually an HTTP API, but may\n  be anything, such as the browser's local storage.\n\n  ### Creating an Adapter\n\n  First, create a new subclass of `DS.Adapter`:\n\n  ```javascript\n  App.MyAdapter = DS.Adapter.extend({\n    // ...your code here\n  });\n  ```\n\n  To tell your store which adapter to use, set its `adapter` property:\n\n  ```javascript\n  App.store = DS.Store.create({\n    adapter: App.MyAdapter.create()\n  });\n  ```\n\n  `DS.Adapter` is an abstract base class that you should override in your\n  application to customize it for your backend. The minimum set of methods\n  that you should implement is:\n\n    * `find()`\n    * `createRecord()`\n    * `updateRecord()`\n    * `deleteRecord()`\n\n  To improve the network performance of your application, you can optimize\n  your adapter by overriding these lower-level methods:\n\n    * `findMany()`\n    * `createRecords()`\n    * `updateRecords()`\n    * `deleteRecords()`\n    * `commit()`\n\n  For an example implementation, see `DS.RESTAdapter`, the\n  included REST adapter.\n\n  @class Adapter\n  @namespace DS\n  @extends Ember.Object\n*/\n\nDS.Adapter = Ember.Object.extend({\n\n  /**\n    The `find()` method is invoked when the store is asked for a record that\n    has not previously been loaded. In response to `find()` being called, you\n    should query your persistence layer for a record with the given ID. Once\n    found, you can asynchronously call the store's `push()` method to push\n    the record into the store.\n\n    Here is an example `find` implementation:\n\n    ```javascript\n    find: function(store, type, id) {\n      var url = type.url;\n      url = url.fmt(id);\n\n      jQuery.getJSON(url, function(data) {\n          // data is a hash of key/value pairs. If your server returns a\n          // root, simply do something like:\n          // store.push(type, id, data.person)\n          store.push(type, id, data);\n      });\n    }\n    ```\n\n    @method find\n  */\n  find: Ember.required(Function),\n\n  /**\n\n    @private\n    @method findAll\n    @param  store\n    @param  type\n    @param  since\n  */\n  findAll: null,\n\n  /**\n\n    @private\n    @method findQuery\n    @param  store\n    @param  type\n    @param  query\n    @param  recordArray\n  */\n  findQuery: null,\n\n  /**\n    If the globally unique IDs for your records should be generated on the client,\n    implement the `generateIdForRecord()` method. This method will be invoked\n    each time you create a new record, and the value returned from it will be\n    assigned to the record's `primaryKey`.\n\n    Most traditional REST-like HTTP APIs will not use this method. Instead, the ID\n    of the record will be set by the server, and your adapter will update the store\n    with the new ID when it calls `didCreateRecord()`. Only implement this method if\n    you intend to generate record IDs on the client-side.\n\n    The `generateIdForRecord()` method will be invoked with the requesting store as\n    the first parameter and the newly created record as the second parameter:\n\n    ```javascript\n    generateIdForRecord: function(store, record) {\n      var uuid = App.generateUUIDWithStatisticallyLowOddsOfCollision();\n      return uuid;\n    }\n    ```\n\n    @method generateIdForRecord\n    @param {DS.Store} store\n    @param {DS.Model} record\n  */\n  generateIdForRecord: null,\n\n  /**\n    Proxies to the serializer's `serialize` method.\n\n    @method serialize\n    @param {DS.Model} record\n    @param {Object}   options\n  */\n  serialize: function(record, options) {\n    return get(record, 'store').serializerFor(record.constructor.typeKey).serialize(record, options);\n  },\n\n  /**\n    Implement this method in a subclass to handle the creation of\n    new records.\n\n    Serializes the record and send it to the server.\n\n    This implementation should call the adapter's `didCreateRecord`\n    method on success or `didError` method on failure.\n\n    @method createRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type   the DS.Model class of the record\n    @param {DS.Model} record\n  */\n  createRecord: Ember.required(Function),\n\n  /**\n    Implement this method in a subclass to handle the updating of\n    a record.\n\n    Serializes the record update and send it to the server.\n\n    @method updateRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type   the DS.Model class of the record\n    @param {DS.Model} record\n  */\n  updateRecord: Ember.required(Function),\n\n  /**\n    Implement this method in a subclass to handle the deletion of\n    a record.\n\n    Sends a delete request for the record to the server.\n\n    @method deleteRecord\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type   the DS.Model class of the record\n    @param {DS.Model} record\n  */\n  deleteRecord: Ember.required(Function),\n\n  /**\n    Find multiple records at once.\n\n    By default, it loops over the provided ids and calls `find` on each.\n    May be overwritten to improve performance and reduce the number of\n    server requests.\n\n    @method findMany\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type   the DS.Model class of the records\n    @param {Array}    ids\n  */\n  findMany: function(store, type, ids) {\n    var promises = map.call(ids, function(id) {\n      return this.find(store, type, id);\n    }, this);\n\n    return Ember.RSVP.all(promises);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/adapter");minispade.register('ember-data/system/changes', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/changes/attribute_change\");\nminispade.require(\"ember-data/system/changes/relationship_change\");\n\n})();\n//@ sourceURL=ember-data/system/changes");minispade.register('ember-data/system/changes/attribute_change', "(function() {/**\n  @module ember-data\n*/\n\n/**\n  An AttributeChange object is created whenever a record's\n  attribute changes value. It is used to track changes to a\n  record between transaction commits.\n\n  @class AttributeChange\n  @namespace DS\n  @private\n  @constructor\n*/\nvar AttributeChange = DS.AttributeChange = function(options) {\n  this.record = options.record;\n  this.store = options.store;\n  this.name = options.name;\n  this.value = options.value;\n  this.oldValue = options.oldValue;\n};\n\nAttributeChange.createChange = function(options) {\n  return new AttributeChange(options);\n};\n\nAttributeChange.prototype = {\n  sync: function() {\n    if (this.value !== this.oldValue) {\n      this.record.send('becomeDirty');\n      this.record.updateRecordArraysLater();\n    }\n\n    // TODO: Use this object in the commit process\n    this.destroy();\n  },\n\n  /**\n    If the AttributeChange is destroyed (either by being rolled back\n    or being committed), remove it from the list of pending changes\n    on the record.\n\n    @method destroy\n  */\n  destroy: function() {\n    delete this.record._changesToSync[this.name];\n  }\n};\n\n})();\n//@ sourceURL=ember-data/system/changes/attribute_change");minispade.register('ember-data/system/changes/relationship_change', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.EnumerableUtils.forEach;\n\n/**\n  @class RelationshipChange\n  @namespace DS\n  @private\n  @construtor\n*/\nDS.RelationshipChange = function(options) {\n  this.parentRecord = options.parentRecord;\n  this.childRecord = options.childRecord;\n  this.firstRecord = options.firstRecord;\n  this.firstRecordKind = options.firstRecordKind;\n  this.firstRecordName = options.firstRecordName;\n  this.secondRecord = options.secondRecord;\n  this.secondRecordKind = options.secondRecordKind;\n  this.secondRecordName = options.secondRecordName;\n  this.changeType = options.changeType;\n  this.store = options.store;\n\n  this.committed = {};\n};\n\n/**\n  @class RelationshipChangeAdd\n  @namespace DS\n  @private\n  @construtor\n*/\nDS.RelationshipChangeAdd = function(options){\n  DS.RelationshipChange.call(this, options);\n};\n\n/**\n  @class RelationshipChangeRemove\n  @namespace DS\n  @private\n  @construtor\n*/\nDS.RelationshipChangeRemove = function(options){\n  DS.RelationshipChange.call(this, options);\n};\n\nDS.RelationshipChange.create = function(options) {\n  return new DS.RelationshipChange(options);\n};\n\nDS.RelationshipChangeAdd.create = function(options) {\n  return new DS.RelationshipChangeAdd(options);\n};\n\nDS.RelationshipChangeRemove.create = function(options) {\n  return new DS.RelationshipChangeRemove(options);\n};\n\nDS.OneToManyChange = {};\nDS.OneToNoneChange = {};\nDS.ManyToNoneChange = {};\nDS.OneToOneChange = {};\nDS.ManyToManyChange = {};\n\nDS.RelationshipChange._createChange = function(options){\n  if(options.changeType === \"add\"){\n    return DS.RelationshipChangeAdd.create(options);\n  }\n  if(options.changeType === \"remove\"){\n    return DS.RelationshipChangeRemove.create(options);\n  }\n};\n\n\nDS.RelationshipChange.determineRelationshipType = function(recordType, knownSide){\n  var knownKey = knownSide.key, key, otherKind;\n  var knownKind = knownSide.kind;\n\n  var inverse = recordType.inverseFor(knownKey);\n\n  if (inverse){\n    key = inverse.name;\n    otherKind = inverse.kind;\n  }\n\n  if (!inverse){\n    return knownKind === \"belongsTo\" ? \"oneToNone\" : \"manyToNone\";\n  }\n  else{\n    if(otherKind === \"belongsTo\"){\n      return knownKind === \"belongsTo\" ? \"oneToOne\" : \"manyToOne\";\n    }\n    else{\n      return knownKind === \"belongsTo\" ? \"oneToMany\" : \"manyToMany\";\n    }\n  }\n\n};\n\nDS.RelationshipChange.createChange = function(firstRecord, secondRecord, store, options){\n  // Get the type of the child based on the child's client ID\n  var firstRecordType = firstRecord.constructor, changeType;\n  changeType = DS.RelationshipChange.determineRelationshipType(firstRecordType, options);\n  if (changeType === \"oneToMany\"){\n    return DS.OneToManyChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"manyToOne\"){\n    return DS.OneToManyChange.createChange(secondRecord, firstRecord, store, options);\n  }\n  else if (changeType === \"oneToNone\"){\n    return DS.OneToNoneChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"manyToNone\"){\n    return DS.ManyToNoneChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"oneToOne\"){\n    return DS.OneToOneChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"manyToMany\"){\n    return DS.ManyToManyChange.createChange(firstRecord, secondRecord, store, options);\n  }\n};\n\nDS.OneToNoneChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key = options.key;\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      store: store,\n      changeType: options.changeType,\n      firstRecordName: key,\n      firstRecordKind: \"belongsTo\"\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n\n  return change;\n};\n\nDS.ManyToNoneChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key = options.key;\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: childRecord,\n      childRecord: parentRecord,\n      secondRecord: childRecord,\n      store: store,\n      changeType: options.changeType,\n      secondRecordName: options.key,\n      secondRecordKind: \"hasMany\"\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n  return change;\n};\n\n\nDS.ManyToManyChange.createChange = function(childRecord, parentRecord, store, options) {\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  var key = options.key;\n\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      secondRecord: parentRecord,\n      firstRecordKind: \"hasMany\",\n      secondRecordKind: \"hasMany\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n\n\n  return change;\n};\n\nDS.OneToOneChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key;\n\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  if (options.parentType) {\n    key = options.parentType.inverseFor(options.key).name;\n  } else if (options.key) {\n    key = options.key;\n  } else {\n    Ember.assert(\"You must pass either a parentType or belongsToName option to OneToManyChange.forChildAndParent\", false);\n  }\n\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      secondRecord: parentRecord,\n      firstRecordKind: \"belongsTo\",\n      secondRecordKind: \"belongsTo\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n\n\n  return change;\n};\n\nDS.OneToOneChange.maintainInvariant = function(options, store, childRecord, key){\n  if (options.changeType === \"add\" && store.recordIsMaterialized(childRecord)) {\n    var oldParent = get(childRecord, key);\n    if (oldParent){\n      var correspondingChange = DS.OneToOneChange.createChange(childRecord, oldParent, store, {\n          parentType: options.parentType,\n          hasManyName: options.hasManyName,\n          changeType: \"remove\",\n          key: options.key\n        });\n      store.addRelationshipChangeFor(childRecord, key, options.parentRecord , null, correspondingChange);\n     correspondingChange.sync();\n    }\n  }\n};\n\nDS.OneToManyChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key;\n\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  if (options.parentType) {\n    key = options.parentType.inverseFor(options.key).name;\n    DS.OneToManyChange.maintainInvariant( options, store, childRecord, key );\n  } else if (options.key) {\n    key = options.key;\n  } else {\n    Ember.assert(\"You must pass either a parentType or belongsToName option to OneToManyChange.forChildAndParent\", false);\n  }\n\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      secondRecord: parentRecord,\n      firstRecordKind: \"belongsTo\",\n      secondRecordKind: \"hasMany\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, change.getSecondRecordName(), change);\n\n\n  return change;\n};\n\n\nDS.OneToManyChange.maintainInvariant = function(options, store, childRecord, key){\n  if (options.changeType === \"add\" && childRecord) {\n    var oldParent = get(childRecord, key);\n    if (oldParent){\n      var correspondingChange = DS.OneToManyChange.createChange(childRecord, oldParent, store, {\n          parentType: options.parentType,\n          hasManyName: options.hasManyName,\n          changeType: \"remove\",\n          key: options.key\n        });\n      store.addRelationshipChangeFor(childRecord, key, options.parentRecord, correspondingChange.getSecondRecordName(), correspondingChange);\n      correspondingChange.sync();\n    }\n  }\n};\n\n/**\n  @class RelationshipChange\n  @namespace DS\n*/\nDS.RelationshipChange.prototype = {\n\n  getSecondRecordName: function() {\n    var name = this.secondRecordName, parent;\n\n    if (!name) {\n      parent = this.secondRecord;\n      if (!parent) { return; }\n\n      var childType = this.firstRecord.constructor;\n      var inverse = childType.inverseFor(this.firstRecordName);\n      this.secondRecordName = inverse.name;\n    }\n\n    return this.secondRecordName;\n  },\n\n  /**\n    Get the name of the relationship on the belongsTo side.\n\n    @method getFirstRecordName\n    @return {String}\n  */\n  getFirstRecordName: function() {\n    var name = this.firstRecordName;\n    return name;\n  },\n\n  /**\n    @method destroy\n    @private\n  */\n  destroy: function() {\n    var childRecord = this.childRecord,\n        belongsToName = this.getFirstRecordName(),\n        hasManyName = this.getSecondRecordName(),\n        store = this.store;\n\n    store.removeRelationshipChangeFor(childRecord, belongsToName, this.parentRecord, hasManyName, this.changeType);\n  },\n\n  getSecondRecord: function(){\n    return this.secondRecord;\n  },\n\n  /**\n    @method getFirstRecord\n    @private\n  */\n  getFirstRecord: function() {\n    return this.firstRecord;\n  },\n\n  coalesce: function(){\n    var relationshipPairs = this.store.relationshipChangePairsFor(this.firstRecord);\n    forEach(relationshipPairs, function(pair){\n      var addedChange = pair[\"add\"];\n      var removedChange = pair[\"remove\"];\n      if(addedChange && removedChange) {\n        addedChange.destroy();\n        removedChange.destroy();\n      }\n    });\n  }\n};\n\nDS.RelationshipChangeAdd.prototype = Ember.create(DS.RelationshipChange.create({}));\nDS.RelationshipChangeRemove.prototype = Ember.create(DS.RelationshipChange.create({}));\n\n// the object is a value, and not a promise\nfunction isValue(object) {\n  return typeof object === 'object' && (!object.then || typeof object.then !== 'function');\n}\n\nDS.RelationshipChangeAdd.prototype.changeType = \"add\";\nDS.RelationshipChangeAdd.prototype.sync = function() {\n  var secondRecordName = this.getSecondRecordName(),\n      firstRecordName = this.getFirstRecordName(),\n      firstRecord = this.getFirstRecord(),\n      secondRecord = this.getSecondRecord();\n\n  //Ember.assert(\"You specified a hasMany (\" + hasManyName + \") on \" + (!belongsToName && (newParent || oldParent || this.lastParent).constructor) + \" but did not specify an inverse belongsTo on \" + child.constructor, belongsToName);\n  //Ember.assert(\"You specified a belongsTo (\" + belongsToName + \") on \" + child.constructor + \" but did not specify an inverse hasMany on \" + (!hasManyName && (newParent || oldParent || this.lastParentRecord).constructor), hasManyName);\n\n  if (secondRecord instanceof DS.Model && firstRecord instanceof DS.Model) {\n    if(this.secondRecordKind === \"belongsTo\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        set(secondRecord, secondRecordName, firstRecord);\n      });\n\n     }\n     else if(this.secondRecordKind === \"hasMany\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        var relationship = get(secondRecord, secondRecordName);\n        if (isValue(relationship)) { relationship.addObject(firstRecord); }\n      });\n    }\n  }\n\n  if (firstRecord instanceof DS.Model && secondRecord instanceof DS.Model && get(firstRecord, firstRecordName) !== secondRecord) {\n    if(this.firstRecordKind === \"belongsTo\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        set(firstRecord, firstRecordName, secondRecord);\n      });\n    }\n    else if(this.firstRecordKind === \"hasMany\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        var relationship = get(firstRecord, firstRecordName);\n        if (isValue(relationship)) { relationship.addObject(secondRecord); }\n      });\n    }\n  }\n\n  this.coalesce();\n};\n\nDS.RelationshipChangeRemove.prototype.changeType = \"remove\";\nDS.RelationshipChangeRemove.prototype.sync = function() {\n  var secondRecordName = this.getSecondRecordName(),\n      firstRecordName = this.getFirstRecordName(),\n      firstRecord = this.getFirstRecord(),\n      secondRecord = this.getSecondRecord();\n\n  //Ember.assert(\"You specified a hasMany (\" + hasManyName + \") on \" + (!belongsToName && (newParent || oldParent || this.lastParent).constructor) + \" but did not specify an inverse belongsTo on \" + child.constructor, belongsToName);\n  //Ember.assert(\"You specified a belongsTo (\" + belongsToName + \") on \" + child.constructor + \" but did not specify an inverse hasMany on \" + (!hasManyName && (newParent || oldParent || this.lastParentRecord).constructor), hasManyName);\n\n  if (secondRecord instanceof DS.Model && firstRecord instanceof DS.Model) {\n    if(this.secondRecordKind === \"belongsTo\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        set(secondRecord, secondRecordName, null);\n      });\n    }\n    else if(this.secondRecordKind === \"hasMany\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        var relationship = get(secondRecord, secondRecordName);\n        if (isValue(relationship)) { relationship.removeObject(firstRecord); }\n      });\n    }\n  }\n\n  if (firstRecord instanceof DS.Model && get(firstRecord, firstRecordName)) {\n    if(this.firstRecordKind === \"belongsTo\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        set(firstRecord, firstRecordName, null);\n      });\n     }\n     else if(this.firstRecordKind === \"hasMany\"){\n       firstRecord.suspendRelationshipObservers(function(){\n         var relationship = get(firstRecord, firstRecordName);\n         if (isValue(relationship)) { relationship.removeObject(secondRecord); }\n      });\n    }\n  }\n\n  this.coalesce();\n};\n\n})();\n//@ sourceURL=ember-data/system/changes/relationship_change");minispade.register('ember-data/system/debug', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/debug/debug_info\");\nminispade.require(\"ember-data/system/debug/debug_adapter\");\n\n})();\n//@ sourceURL=ember-data/system/debug");minispade.register('ember-data/system/debug/debug_adapter', "(function() {/**\n  @module ember-data\n*/\nvar get = Ember.get, capitalize = Ember.String.capitalize, underscore = Ember.String.underscore, DS = window.DS ;\n\n/**\n  Extend `Ember.DataAdapter` with ED specific code.\n\n  @class DebugAdapter\n  @namespace DS\n  @extends Ember.DataAdapter\n  @private\n*/\nDS.DebugAdapter = Ember.DataAdapter.extend({\n  getFilters: function() {\n    return [\n      { name: 'isNew', desc: 'New' },\n      { name: 'isModified', desc: 'Modified' },\n      { name: 'isClean', desc: 'Clean' }\n    ];\n  },\n\n  detect: function(klass) {\n    return klass !== DS.Model && DS.Model.detect(klass);\n  },\n\n  columnsForType: function(type) {\n    var columns = [{ name: 'id', desc: 'Id' }], count = 0, self = this;\n    get(type, 'attributes').forEach(function(name, meta) {\n        if (count++ > self.attributeLimit) { return false; }\n        var desc = capitalize(underscore(name).replace('_', ' '));\n        columns.push({ name: name, desc: desc });\n    });\n    return columns;\n  },\n\n  getRecords: function(type) {\n    return this.get('store').all(type);\n  },\n\n  getRecordColumnValues: function(record) {\n    var self = this, count = 0,\n        columnValues = { id: get(record, 'id') };\n\n    record.eachAttribute(function(key) {\n      if (count++ > self.attributeLimit) {\n        return false;\n      }\n      var value = get(record, key);\n      columnValues[key] = value;\n    });\n    return columnValues;\n  },\n\n  getRecordKeywords: function(record) {\n    var keywords = [], keys = Ember.A(['id']);\n    record.eachAttribute(function(key) {\n      keys.push(key);\n    });\n    keys.forEach(function(key) {\n      keywords.push(get(record, key));\n    });\n    return keywords;\n  },\n\n  getRecordFilterValues: function(record) {\n    return {\n      isNew: record.get('isNew'),\n      isModified: record.get('isDirty') && !record.get('isNew'),\n      isClean: !record.get('isDirty')\n    };\n  },\n\n  getRecordColor: function(record) {\n    var color = 'black';\n    if (record.get('isNew')) {\n      color = 'green';\n    } else if (record.get('isDirty')) {\n      color = 'blue';\n    }\n    return color;\n  },\n\n  observeRecord: function(record, recordUpdated) {\n    var releaseMethods = Ember.A(), self = this,\n        keysToObserve = Ember.A(['id', 'isNew', 'isDirty']);\n\n    record.eachAttribute(function(key) {\n      keysToObserve.push(key);\n    });\n\n    keysToObserve.forEach(function(key) {\n      var handler = function() {\n        recordUpdated(self.wrapRecord(record));\n      };\n      Ember.addObserver(record, key, handler);\n      releaseMethods.push(function() {\n        Ember.removeObserver(record, key, handler);\n      });\n    });\n\n    var release = function() {\n      releaseMethods.forEach(function(fn) { fn(); } );\n    };\n\n    return release;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/debug/debug_adapter");minispade.register('ember-data/system/debug/debug_info', "(function() {minispade.require(\"ember-data/system/model/model\");\n\nDS.Model.reopen({\n\n  /**\n    Provides info about the model for debugging purposes\n    by grouping the properties into more semantic groups.\n\n    Meant to be used by debugging tools such as the Chrome Ember Extension.\n\n    - Groups all attributes in \"Attributes\" group.\n    - Groups all belongsTo relationships in \"Belongs To\" group.\n    - Groups all hasMany relationships in \"Has Many\" group.\n    - Groups all flags in \"Flags\" group.\n    - Flags relationship CPs as expensive properties.\n\n    @method _debugInfo\n    @for DS.Model\n    @private\n  */\n  _debugInfo: function() {\n    var attributes = ['id'],\n        relationships = { belongsTo: [], hasMany: [] },\n        expensiveProperties = [];\n\n    this.eachAttribute(function(name, meta) {\n      attributes.push(name);\n    }, this);\n\n    this.eachRelationship(function(name, relationship) {\n      relationships[relationship.kind].push(name);\n      expensiveProperties.push(name);\n    });\n\n    var groups = [\n      {\n        name: 'Attributes',\n        properties: attributes,\n        expand: true\n      },\n      {\n        name: 'Belongs To',\n        properties: relationships.belongsTo,\n        expand: true\n      },\n      {\n        name: 'Has Many',\n        properties: relationships.hasMany,\n        expand: true\n      },\n      {\n        name: 'Flags',\n        properties: ['isLoaded', 'isDirty', 'isSaving', 'isDeleted', 'isError', 'isNew', 'isValid']\n      }\n    ];\n\n    return {\n      propertyInfo: {\n        // include all other mixins / properties (not just the grouped ones)\n        includeOtherProperties: true,\n        groups: groups,\n        // don't pre-calculate unless cached\n        expensiveProperties: expensiveProperties\n      }\n    };\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/debug/debug_info");minispade.register('ember-data/system/model', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/model/model\");\nminispade.require(\"ember-data/system/model/states\");\nminispade.require(\"ember-data/system/model/attributes\");\n\n})();\n//@ sourceURL=ember-data/system/model");minispade.register('ember-data/system/model/attributes', "(function() {minispade.require(\"ember-data/system/model/model\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get;\n\n/**\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopenClass({\n  /**\n    A map whose keys are the attributes of the model (properties\n    described by DS.attr) and whose values are the meta object for the\n    property.\n\n    Example\n\n    ```javascript\n\n    App.Person = DS.Model.extend({\n      firstName: attr('string'),\n      lastName: attr('string'),\n      birthday: attr('date')\n    });\n\n    var attributes = Ember.get(App.Person, 'attributes')\n\n    attributes.forEach(function(name, meta) {\n      console.log(name, meta);\n    });\n\n    // prints:\n    // firstName {type: \"string\", isAttribute: true, options: Object, parentType: function, name: \"firstName\"}\n    // lastName {type: \"string\", isAttribute: true, options: Object, parentType: function, name: \"lastName\"}\n    // birthday {type: \"date\", isAttribute: true, options: Object, parentType: function, name: \"birthday\"}\n    ```\n\n    @property attributes\n    @static\n    @type {Ember.Map}\n    @readOnly\n  */\n  attributes: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isAttribute) {\n        Ember.assert(\"You may not set `id` as an attribute on your model. Please remove any lines that look like: `id: DS.attr('<type>')` from \" + this.toString(), name !== 'id');\n\n        meta.name = name;\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A map whose keys are the attributes of the model (properties\n    described by DS.attr) and whose values are type of transformation\n    applied to each attribute. This map does not include any\n    attributes that do not have an transformation type.\n\n    Example\n\n    ```javascript\n    App.Person = DS.Model.extend({\n      firstName: attr(),\n      lastName: attr('string'),\n      birthday: attr('date')\n    });\n\n    var transformedAttributes = Ember.get(App.Person, 'transformedAttributes')\n\n    transformedAttributes.forEach(function(field, type) {\n      console.log(field, type);\n    });\n\n    // prints:\n    // lastName string\n    // birthday date\n    ```\n\n    @property transformedAttributes\n    @static\n    @type {Ember.Map}\n    @readOnly\n  */\n  transformedAttributes: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachAttribute(function(key, meta) {\n      if (meta.type) {\n        map.set(key, meta.type);\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    Iterates through the attributes of the model, calling the passed function on each\n    attribute.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n    ```javascript\n    function(name, meta);\n    ```\n\n    - `name` the name of the current property in the iteration\n    - `meta` the meta object for the attribute property in the iteration\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as `this` on the context.\n\n    Example\n\n    ```javascript\n    App.Person = DS.Model.extend({\n      firstName: attr('string'),\n      lastName: attr('string'),\n      birthday: attr('date')\n    });\n\n    App.Person.eachAttribute(function(name, meta) {\n      console.log(name, meta);\n    });\n\n    // prints:\n    // firstName {type: \"string\", isAttribute: true, options: Object, parentType: function, name: \"firstName\"}\n    // lastName {type: \"string\", isAttribute: true, options: Object, parentType: function, name: \"lastName\"}\n    // birthday {type: \"date\", isAttribute: true, options: Object, parentType: function, name: \"birthday\"}\n   ```\n\n    @method eachAttribute\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @static\n  */\n  eachAttribute: function(callback, binding) {\n    get(this, 'attributes').forEach(function(name, meta) {\n      callback.call(binding, name, meta);\n    }, binding);\n  },\n\n  /**\n    Iterates through the transformedAttributes of the model, calling\n    the passed function on each attribute. Note the callback will not be\n    called for any attributes that do not have an transformation type.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n    ```javascript\n    function(name, type);\n    ```\n\n    - `name` the name of the current property in the iteration\n    - `type` a tring contrining the name of the type of transformed\n      applied to the attribute\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as `this` on the context.\n\n    Example\n\n    ```javascript\n    App.Person = DS.Model.extend({\n      firstName: attr(),\n      lastName: attr('string'),\n      birthday: attr('date')\n    });\n\n    App.Person.eachTransformedAttribute(function(name, type) {\n      console.log(name, type);\n    });\n\n    // prints:\n    // lastName string\n    // birthday date\n   ```\n\n    @method eachTransformedAttribute\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @static\n  */\n  eachTransformedAttribute: function(callback, binding) {\n    get(this, 'transformedAttributes').forEach(function(name, type) {\n      callback.call(binding, name, type);\n    });\n  }\n});\n\n\nDS.Model.reopen({\n  eachAttribute: function(callback, binding) {\n    this.constructor.eachAttribute(callback, binding);\n  }\n});\n\nfunction getDefaultValue(record, options, key) {\n  if (typeof options.defaultValue === \"function\") {\n    return options.defaultValue();\n  } else {\n    return options.defaultValue;\n  }\n}\n\nfunction hasValue(record, key) {\n  return record._attributes.hasOwnProperty(key) ||\n         record._inFlightAttributes.hasOwnProperty(key) ||\n         record._data.hasOwnProperty(key);\n}\n\nfunction getValue(record, key) {\n  if (record._attributes.hasOwnProperty(key)) {\n    return record._attributes[key];\n  } else if (record._inFlightAttributes.hasOwnProperty(key)) {\n    return record._inFlightAttributes[key];\n  } else {\n    return record._data[key];\n  }\n}\n\n/**\n  `DS.attr` defines an attribute on a [DS.Model](DS.Model.html).\n  By default, attributes are passed through as-is, however you can specify an\n  optional type to have the value automatically transformed.\n  Ember Data ships with four basic transform types: `string`, `number`,\n  `boolean` and `date`. You can define your own transforms by subclassing\n  [DS.Transform](DS.Transform.html).\n\n  `DS.attr` takes an optional hash as a second parameter, currently\n  supported options are:\n\n  - `defaultValue`: Pass a string or a function to be called to set the attribute\n                    to a default value if none is supplied.\n\n  Example\n\n  ```javascript\n  var attr = DS.attr;\n\n  App.User = DS.Model.extend({\n    username: attr('string'),\n    email: attr('string'),\n    verified: attr('boolean', {defaultValue: false})\n  });\n  ```\n\n  @namespace\n  @method attr\n  @for DS\n  @param {String} type the attribute type\n  @param {Object} options a hash of options\n  @return {Attribute}\n*/\n\nDS.attr = function(type, options) {\n  options = options || {};\n\n  var meta = {\n    type: type,\n    isAttribute: true,\n    options: options\n  };\n\n  return Ember.computed(function(key, value) {\n    if (arguments.length > 1) {\n      Ember.assert(\"You may not set `id` as an attribute on your model. Please remove any lines that look like: `id: DS.attr('<type>')` from \" + this.constructor.toString(), key !== 'id');\n      var oldValue = this._attributes[key] || this._inFlightAttributes[key] || this._data[key];\n\n      this.send('didSetProperty', {\n        name: key,\n        oldValue: oldValue,\n        originalValue: this._data[key],\n        value: value\n      });\n\n      this._attributes[key] = value;\n      return value;\n    } else if (hasValue(this, key)) {\n      return getValue(this, key);\n    } else {\n      return getDefaultValue(this, options, key);\n    }\n\n  // `data` is never set directly. However, it may be\n  // invalidated from the state manager's setData\n  // event.\n  }).property('data').meta(meta);\n};\n\n\n})();\n//@ sourceURL=ember-data/system/model/attributes");minispade.register('ember-data/system/model/model', "(function() {minispade.require(\"ember-data/system/model/states\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set,\n    merge = Ember.merge, once = Ember.run.once;\n\nvar retrieveFromCurrentState = Ember.computed('currentState', function(key, value) {\n  return get(get(this, 'currentState'), key);\n}).readOnly();\n\n/**\n\n  The model class that all Ember Data records descend from.\n\n  @class Model\n  @namespace DS\n  @extends Ember.Object\n  @uses Ember.Evented\n*/\nDS.Model = Ember.Object.extend(Ember.Evented, {\n  /**\n    If this property is `true` the record is in the `empty`\n    state. Empty is the first state all records enter after they have\n    been created. Most records created by the store will quickly\n    transition to the `loading` state if data needs to be fetched from\n    the server or the `created` state if the record is created on the\n    client. A record can also enter the empty state if the adapter is\n    unable to locate the record.\n\n    @property isEmpty\n    @type {Boolean}\n    @readOnly\n  */\n  isEmpty: retrieveFromCurrentState,\n  /**\n    If this property is `true` the record is in the `loading` state. A\n    record enters this state when the store askes the adapter for its\n    data. It remains in this state until the adapter provides the\n    requested data.\n\n    @property isLoading\n    @type {Boolean}\n    @readOnly\n  */\n  isLoading: retrieveFromCurrentState,\n  /**\n    If this property is `true` the record is in the `loaded` state. A\n    record enters this state when its data is populated. Most of a\n    record's lifecycle is spent inside substates of the `loaded`\n    state.\n\n    Example\n\n    ```javascript\n    var record = store.createRecord(App.Model);\n    record.get('isLoaded'); // true\n\n    store.find('model', 1).then(function(model) {\n      model.get('isLoaded'); // true\n    });\n    ```\n\n    @property isLoaded\n    @type {Boolean}\n    @readOnly\n  */\n  isLoaded: retrieveFromCurrentState,\n  /**\n    If this property is `true` the record is in the `dirty` state. The\n    record has local changes that have not yet been saved by the\n    adapter. This includes records that have been created (but not yet\n    saved) or deleted.\n\n    Example\n\n    ```javascript\n    var record = store.createRecord(App.Model);\n    record.get('isDirty'); // true\n\n    store.find('model', 1).then(function(model) {\n      model.get('isDirty'); // false\n      model.set('foo', 'some value');\n      model.set('isDirty'); // true\n    });\n    ```\n\n    @property isDirty\n    @type {Boolean}\n    @readOnly\n  */\n  isDirty: retrieveFromCurrentState,\n  /**\n    If this property is `true` the record is in the `saving` state. A\n    record enters the saving state when `save` is called, but the\n    adapter has not yet acknowledged that the changes have been\n    persisted to the backend.\n\n    Example\n\n    ```javascript\n    var record = store.createRecord(App.Model);\n    record.get('isSaving'); // false\n    var promise = record.save();\n    record.get('isSaving'); // true\n    promise.then(function() {\n      record.get('isSaving'); // false\n    });\n    ```\n\n    @property isSaving\n    @type {Boolean}\n    @readOnly\n  */\n  isSaving: retrieveFromCurrentState,\n  /**\n    If this property is `true` the record is in the `deleted` state\n    and has been marked for deletion. When `isDeleted` is true and\n    `isDirty` is true, the record is deleted locally but the deletion\n    was not yet persisted. When `isSaving` is true, the change is\n    in-flight. When both `isDirty` and `isSaving` are false, the\n    change has persisted.\n\n    Example\n\n    ```javascript\n    var record = store.createRecord(App.Model);\n    record.get('isDeleted'); // false\n    record.deleteRecord();\n    record.get('isDeleted'); // true\n    ```\n\n    @property isDeleted\n    @type {Boolean}\n    @readOnly\n  */\n  isDeleted: retrieveFromCurrentState,\n  /**\n    If this property is `true` the record is in the `new` state. A\n    record will be in the `new` state when it has been created on the\n    client and the adapter has not yet report that it was successfully\n    saved.\n\n    Example\n\n    ```javascript\n    var record = store.createRecord(App.Model);\n    record.get('isNew'); // true\n\n    store.find('model', 1).then(function(model) {\n      model.get('isNew'); // false\n    });\n    ```\n\n    @property isNew\n    @type {Boolean}\n    @readOnly\n  */\n  isNew: retrieveFromCurrentState,\n  /**\n    If this property is `true` the record is in the `valid` state. A\n    record will be in the `valid` state when no client-side\n    validations have failed and the adapter did not report any\n    server-side validation failures.\n\n    @property isValid\n    @type {Boolean}\n    @readOnly\n  */\n  isValid: retrieveFromCurrentState,\n  /**\n    If the record is in the dirty state this property will report what\n    kind of change has caused it to move into the dirty\n    state. Possible values are:\n\n    - `created` The record has been created by the client and not yet saved to the adapter.\n    - `updated` The record has been updated by the client and not yet saved to the adapter.\n    - `deleted` The record has been deleted by the client and not yet saved to the adapter.\n\n    Example\n\n    ```javascript\n    var record = store.createRecord(App.Model);\n    record.get('dirtyType'); // 'created'\n    ```\n\n    @property dirtyType\n    @type {String}\n    @readOnly\n  */\n  dirtyType: retrieveFromCurrentState,\n\n  /**\n    If `true` the adapter reported that it was unable to save local\n    changes to the backend. This may also result in the record having\n    its `isValid` property become false if the adapter reported that\n    server-side validations failed.\n\n    Example\n\n    ```javascript\n    record.get('isError'); // false\n    record.set('foo', 'invalid value');\n    record.save().then(null, function() {\n      record.get('isError'); // true\n    });\n    ```\n\n    @property isError\n    @type {Boolean}\n    @readOnly\n  */\n  isError: false,\n  /**\n    If `true` the store is attempting to reload the record form the adapter.\n\n    Example\n\n    ```javascript\n    record.get('isReloading'); // false\n    record.reload();\n    record.get('isReloading'); // true\n    ```\n\n    @property isReloading\n    @type {Boolean}\n    @readOnly\n  */\n  isReloading: false,\n\n  /**\n    The `clientId` property is a transient numerical identifier\n    generated at runtime by the data store. It is important\n    primarily because newly created objects may not yet have an\n    externally generated id.\n\n    @property clientId\n    @private\n    @type {Number|String}\n  */\n  clientId: null,\n  /**\n    All ember models have an id property. This is an identifier\n    managed by an external source. These are always coerced to be\n    strings before being used internally. Note when declaring the\n    attributes for a model it is an error to declare an id\n    attribute.\n\n    ```javascript\n    var record = store.createRecord(App.Model);\n    record.get('id'); // null\n\n    store.find('model', 1).then(function(model) {\n      model.get('id'); // '1'\n    });\n    ```\n\n    @property id\n    @type {String}\n  */\n  id: null,\n  transaction: null,\n  /**\n    @property currentState\n    @private\n    @type {Object}\n  */\n  currentState: null,\n  /**\n    When the record is in the `invalid` state this object will contain\n    any errors returned by the adapter. When present the errors hash\n    typically contains keys coresponding to the invalid property names\n    and values which are an array of error messages.\n\n    ```javascript\n    record.get('errors'); // null\n    record.set('foo', 'invalid value');\n    record.save().then(null, function() {\n      record.get('errors'); // {foo: ['foo should be a number.']}\n    });\n    ```\n\n    @property errors\n    @type {Object}\n  */\n  errors: null,\n\n  /**\n    Create a JSON representation of the record, using the serialization\n    strategy of the store's adapter.\n\n   `serialize` takes an optional hash as a parameter, currently\n    supported options are:\n\n   - `includeId`: `true` if the record's ID should be included in the\n      JSON representation.\n\n    @method serialize\n    @param {Object} options\n    @returns {Object} an object whose values are primitive JSON values only\n  */\n  serialize: function(options) {\n    var store = get(this, 'store');\n    return store.serialize(this, options);\n  },\n\n  /**\n    Use [DS.JSONSerializer](DS.JSONSerializer.html) to\n    get the JSON representation of a record.\n\n    `toJSON` takes an optional hash as a parameter, currently\n    supported options are:\n\n    - `includeId`: `true` if the record's ID should be included in the\n      JSON representation.\n\n    @method toJSON\n    @param {Object} options\n    @returns {Object} A JSON representation of the object.\n  */\n  toJSON: function(options) {\n    // container is for lazy transform lookups\n    var serializer = DS.JSONSerializer.create({ container: this.container });\n    return serializer.serialize(this, options);\n  },\n\n  /**\n    Fired when the record is loaded from the server.\n\n    @event didLoad\n  */\n  didLoad: Ember.K,\n\n  /**\n    Fired when the record is updated.\n\n    @event didUpdate\n  */\n  didUpdate: Ember.K,\n\n  /**\n    Fired when the record is created.\n\n    @event didCreate\n  */\n  didCreate: Ember.K,\n\n  /**\n    Fired when the record is deleted.\n\n    @event didDelete\n  */\n  didDelete: Ember.K,\n\n  /**\n    Fired when the record becomes invalid.\n\n    @event becameInvalid\n  */\n  becameInvalid: Ember.K,\n\n  /**\n    Fired when the record enters the error state.\n\n    @event becameError\n  */\n  becameError: Ember.K,\n\n  /**\n    @property data\n    @private\n    @type {Object}\n  */\n  data: Ember.computed(function() {\n    this._data = this._data || {};\n    return this._data;\n  }).property(),\n\n  _data: null,\n\n  init: function() {\n    set(this, 'currentState', DS.RootState.empty);\n    this._super();\n    this._setup();\n  },\n\n  _setup: function() {\n    this._changesToSync = {};\n    this._deferredTriggers = [];\n    this._data = {};\n    this._attributes = {};\n    this._inFlightAttributes = {};\n    this._relationships = {};\n  },\n\n  /**\n    @method send\n    @private\n    @param {String} name\n    @param {Object} context\n  */\n  send: function(name, context) {\n    var currentState = get(this, 'currentState');\n\n    if (!currentState[name]) {\n      this._unhandledEvent(currentState, name, context);\n    }\n\n    return currentState[name](this, context);\n  },\n\n  /**\n    @method transitionTo\n    @private\n    @param {String} name\n  */\n  transitionTo: function(name) {\n    // POSSIBLE TODO: Remove this code and replace with\n    // always having direct references to state objects\n\n    var pivotName = name.split(\".\", 1),\n        currentState = get(this, 'currentState'),\n        state = currentState;\n\n    do {\n      if (state.exit) { state.exit(this); }\n      state = state.parentState;\n    } while (!state.hasOwnProperty(pivotName));\n\n    var path = name.split(\".\");\n\n    var setups = [], enters = [], i, l;\n\n    for (i=0, l=path.length; i<l; i++) {\n      state = state[path[i]];\n\n      if (state.enter) { enters.push(state); }\n      if (state.setup) { setups.push(state); }\n    }\n\n    for (i=0, l=enters.length; i<l; i++) {\n      enters[i].enter(this);\n    }\n\n    set(this, 'currentState', state);\n\n    for (i=0, l=setups.length; i<l; i++) {\n      setups[i].setup(this);\n    }\n\n    this.updateRecordArraysLater();\n  },\n\n  _unhandledEvent: function(state, name, context) {\n    var errorMessage = \"Attempted to handle event `\" + name + \"` \";\n    errorMessage    += \"on \" + String(this) + \" while in state \";\n    errorMessage    += state.stateName + \". \";\n\n    if (context !== undefined) {\n      errorMessage  += \"Called with \" + Ember.inspect(context) + \".\";\n    }\n\n    throw new Ember.Error(errorMessage);\n  },\n\n  withTransaction: function(fn) {\n    var transaction = get(this, 'transaction');\n    if (transaction) { fn(transaction); }\n  },\n\n  /**\n    @method loadingData\n    @private\n    @param {Promise} promise\n  */\n  loadingData: function(promise) {\n    this.send('loadingData', promise);\n  },\n\n  /**\n    @method loadedData\n    @private\n  */\n  loadedData: function() {\n    this.send('loadedData');\n  },\n\n  /**\n    @method notFound\n    @private\n  */\n  notFound: function() {\n    this.send('notFound');\n  },\n\n  /**\n    @method pushedData\n    @private\n  */\n  pushedData: function() {\n    this.send('pushedData');\n  },\n\n  /**\n    Marks the record as deleted but does not save it. You must call\n    `save` afterwards if you want to persist it. You might use this\n    method if you want to allow the user to still `rollback()` a\n    delete after it was made.\n\n    Example\n\n    ```javascript\n    App.ModelDeleteRoute = Ember.Route.extend({\n      actions: {\n        softDelete: function() {\n          this.get('model').deleteRecord();\n        },\n        confirm: function() {\n          this.get('model').save();\n        },\n        undo: function() {\n          this.get('model').rollback();\n        }\n      }\n    });\n    ```\n\n    @method deleteRecord\n  */\n  deleteRecord: function() {\n    this.send('deleteRecord');\n  },\n\n  /**\n    Same as `deleteRecord`, but saves the record immediately.\n\n    Example\n\n    ```javascript\n    App.ModelDeleteRoute = Ember.Route.extend({\n      actions: {\n        delete: function() {\n          var controller = this.controller;\n          this.get('model').destroyRecord().then(function() {\n            controller.transitionToRoute('model.index');\n          });\n        }\n      }\n    });\n    ```\n\n    @method destroyRecord\n    @return {Promise} a promise that will be resolved when the adapter returns\n    successfully or rejected if the adapter returns with an error.\n  */\n  destroyRecord: function() {\n    this.deleteRecord();\n    return this.save();\n  },\n\n  /**\n    @method unloadRecord\n    @private\n  */\n  unloadRecord: function() {\n    Ember.assert(\"You can only unload a loaded, non-dirty record.\", !get(this, 'isDirty'));\n\n    this.send('unloadRecord');\n  },\n\n  /**\n    @method clearRelationships\n    @private\n  */\n  clearRelationships: function() {\n    this.eachRelationship(function(name, relationship) {\n      if (relationship.kind === 'belongsTo') {\n        set(this, name, null);\n      } else if (relationship.kind === 'hasMany') {\n        var hasMany = this._relationships[relationship.name];\n        if (hasMany) { hasMany.clear(); }\n      }\n    }, this);\n  },\n\n  /**\n    @method updateRecordArrays\n    @private\n  */\n  updateRecordArrays: function() {\n    get(this, 'store').dataWasUpdated(this.constructor, this);\n  },\n\n  /**\n    Returns an object, whose keys are changed properties, and value is\n    an [oldProp, newProp] array.\n\n    Example\n\n    ```javascript\n    App.Mascot = DS.Model.extend({\n      name: attr('string')\n    });\n\n    var person = store.createRecord('person');\n    person.changedAttributes(); // {}\n    person.set('name', 'Tomster');\n    person.changedAttributes(); // {name: [undefined, 'Tomster']}\n    ```\n\n    @method changedAttributes\n    @return {Object} an object, whose keys are changed properties,\n      and value is an [oldProp, newProp] array.\n  */\n  changedAttributes: function() {\n    var oldData = get(this, '_data'),\n        newData = get(this, '_attributes'),\n        diffData = {},\n        prop;\n\n    for (prop in newData) {\n      diffData[prop] = [oldData[prop], newData[prop]];\n    }\n\n    return diffData;\n  },\n\n  /**\n    @method adapterWillCommit\n    @private\n  */\n  adapterWillCommit: function() {\n    this.send('willCommit');\n  },\n\n  /**\n    If the adapter did not return a hash in response to a commit,\n    merge the changed attributes and relationships into the existing\n    saved data.\n\n    @method adapterDidCommit\n  */\n  adapterDidCommit: function(data) {\n    set(this, 'isError', false);\n\n    if (data) {\n      this._data = data;\n    } else {\n      Ember.mixin(this._data, this._inFlightAttributes);\n    }\n\n    this._inFlightAttributes = {};\n\n    this.send('didCommit');\n    this.updateRecordArraysLater();\n\n    if (!data) { return; }\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  /**\n    @method adapterDidDirty\n    @private\n  */\n  adapterDidDirty: function() {\n    this.send('becomeDirty');\n    this.updateRecordArraysLater();\n  },\n\n  dataDidChange: Ember.observer(function() {\n    this.reloadHasManys();\n  }, 'data'),\n\n  reloadHasManys: function() {\n    var relationships = get(this.constructor, 'relationshipsByName');\n    this.updateRecordArraysLater();\n    relationships.forEach(function(name, relationship) {\n      if (this._data.links && this._data.links[name]) { return; }\n      if (relationship.kind === 'hasMany') {\n        this.hasManyDidChange(relationship.key);\n      }\n    }, this);\n  },\n\n  hasManyDidChange: function(key) {\n    var hasMany = this._relationships[key];\n\n    if (hasMany) {\n      var records = this._data[key] || [];\n\n      set(hasMany, 'content', Ember.A(records));\n      set(hasMany, 'isLoaded', true);\n      hasMany.trigger('didLoad');\n    }\n  },\n\n  /**\n    @method updateRecordArraysLater\n    @private\n  */\n  updateRecordArraysLater: function() {\n    Ember.run.once(this, this.updateRecordArrays);\n  },\n\n  /**\n    @method setupData\n    @private\n    @param {Object} data\n    @param {Boolean} partial the data should be merged into\n      the existing data, not replace it.\n  */\n  setupData: function(data, partial) {\n    if (partial) {\n      Ember.merge(this._data, data);\n    } else {\n      this._data = data;\n    }\n\n    var relationships = this._relationships;\n\n    this.eachRelationship(function(name, rel) {\n      if (data.links && data.links[name]) { return; }\n      if (rel.options.async) { relationships[name] = null; }\n    });\n\n    if (data) { this.pushedData(); }\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  materializeId: function(id) {\n    set(this, 'id', id);\n  },\n\n  materializeAttributes: function(attributes) {\n    Ember.assert(\"Must pass a hash of attributes to materializeAttributes\", !!attributes);\n    merge(this._data, attributes);\n  },\n\n  materializeAttribute: function(name, value) {\n    this._data[name] = value;\n  },\n\n  /**\n    @method updateHasMany\n    @private\n    @param {String} name\n    @param {Array} records\n  */\n  updateHasMany: function(name, records) {\n    this._data[name] = records;\n    this.hasManyDidChange(name);\n  },\n\n  /**\n    @method updateBelongsTo\n    @private\n    @param {String} name\n    @param {DS.Model} record\n  */\n  updateBelongsTo: function(name, record) {\n    this._data[name] = record;\n  },\n\n  /**\n    If the model `isDirty` this function will which discard any unsaved\n    changes\n\n    Example\n\n    ```javascript\n    record.get('name'); // 'Untitled Document'\n    record.set('name', 'Doc 1');\n    record.get('name'); // 'Doc 1'\n    record.rollback();\n    record.get('name'); // 'Untitled Document'\n    ```\n\n    @method rollback\n  */\n  rollback: function() {\n    this._attributes = {};\n\n    if (get(this, 'isError')) {\n      this._inFlightAttributes = {};\n      set(this, 'isError', false);\n    }\n    \n    if (!get(this, 'isValid')) {\n      this._inFlightAttributes = {};\n      this.send('becameValid');\n    } \n  \n    this.send('rolledBack');\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  toStringExtension: function() {\n    return get(this, 'id');\n  },\n\n  /**\n    The goal of this method is to temporarily disable specific observers\n    that take action in response to application changes.\n\n    This allows the system to make changes (such as materialization and\n    rollback) that should not trigger secondary behavior (such as setting an\n    inverse relationship or marking records as dirty).\n\n    The specific implementation will likely change as Ember proper provides\n    better infrastructure for suspending groups of observers, and if Array\n    observation becomes more unified with regular observers.\n\n    @method suspendRelationshipObservers\n    @private\n    @param callback\n    @param binding\n  */\n  suspendRelationshipObservers: function(callback, binding) {\n    var observers = get(this.constructor, 'relationshipNames').belongsTo;\n    var self = this;\n\n    try {\n      this._suspendedRelationships = true;\n      Ember._suspendObservers(self, observers, null, 'belongsToDidChange', function() {\n        Ember._suspendBeforeObservers(self, observers, null, 'belongsToWillChange', function() {\n          callback.call(binding || self);\n        });\n      });\n    } finally {\n      this._suspendedRelationships = false;\n    }\n  },\n\n  /**\n    Save the record and persist any changes to the record to an\n    extenal source via the adapter.\n\n    Example\n\n    ```javascript\n    record.set('name', 'Tomster');\n    record.save().then(function(){\n      // Success callback\n    }, function() {\n      // Error callback\n    });\n    ```\n    @method save\n    @return {Promise} a promise that will be resolved when the adapter returns\n    successfully or rejected if the adapter returns with an error.\n  */\n  save: function() {\n    var promiseLabel = \"DS: Model#save \" + this;\n    var resolver = Ember.RSVP.defer(promiseLabel);\n\n    this.get('store').scheduleSave(this, resolver);\n    this._inFlightAttributes = this._attributes;\n    this._attributes = {};\n\n    return DS.PromiseObject.create({ promise: resolver.promise });\n  },\n\n  /**\n    Reload the record from the adapter.\n\n    This will only work if the record has already finished loading\n    and has not yet been modified (`isLoaded` but not `isDirty`,\n    or `isSaving`).\n\n    Example\n\n    ```javascript\n    App.ModelViewRoute = Ember.Route.extend({\n      actions: {\n        reload: function() {\n          this.get('model').reload();\n        }\n      }\n    });\n    ```\n\n    @method reload\n    @return {Promise} a promise that will be resolved with the record when the\n    adapter returns successfully or rejected if the adapter returns\n    with an error.\n  */\n  reload: function() {\n    set(this, 'isReloading', true);\n\n    var  record = this;\n\n    var promiseLabel = \"DS: Model#reload of \" + this;\n    var promise = new Ember.RSVP.Promise(function(resolve){\n       record.send('reloadRecord', resolve);\n    }, promiseLabel).then(function() {\n      record.set('isReloading', false);\n      record.set('isError', false);\n      return record;\n    }, function(reason) {\n      record.set('isError', true);\n      throw reason;\n    }, \"DS: Model#reload complete, update flags\");\n\n    return DS.PromiseObject.create({ promise: promise });\n  },\n\n  // FOR USE DURING COMMIT PROCESS\n\n  adapterDidUpdateAttribute: function(attributeName, value) {\n\n    // If a value is passed in, update the internal attributes and clear\n    // the attribute cache so it picks up the new value. Otherwise,\n    // collapse the current value into the internal attributes because\n    // the adapter has acknowledged it.\n    if (value !== undefined) {\n      this._data[attributeName] = value;\n      this.notifyPropertyChange(attributeName);\n    } else {\n      this._data[attributeName] = this._inFlightAttributes[attributeName];\n    }\n\n    this.updateRecordArraysLater();\n  },\n\n  /**\n    @method adapterDidInvalidate\n    @private\n  */\n  adapterDidInvalidate: function(errors) {\n    this.send('becameInvalid', errors);\n  },\n\n  /**\n    @method adapterDidError\n    @private\n  */\n  adapterDidError: function() {\n    this.send('becameError');\n    set(this, 'isError', true);\n  },\n\n  /**\n    Override the default event firing from Ember.Evented to\n    also call methods with the given name.\n\n    @method trigger\n    @private\n    @param name\n  */\n  trigger: function(name) {\n    Ember.tryInvoke(this, name, [].slice.call(arguments, 1));\n    this._super.apply(this, arguments);\n  },\n\n  triggerLater: function() {\n    this._deferredTriggers.push(arguments);\n    once(this, '_triggerDeferredTriggers');\n  },\n\n  _triggerDeferredTriggers: function() {\n    for (var i=0, l=this._deferredTriggers.length; i<l; i++) {\n      this.trigger.apply(this, this._deferredTriggers[i]);\n    }\n\n    this._deferredTriggers = [];\n  }\n});\n\nDS.Model.reopenClass({\n\n  /**\n    Alias DS.Model's `create` method to `_create`. This allows us to create DS.Model\n    instances from within the store, but if end users accidentally call `create()`\n    (instead of `createRecord()`), we can raise an error.\n\n    @method _create\n    @private\n    @static\n  */\n  _create: DS.Model.create,\n\n  /**\n    Override the class' `create()` method to raise an error. This\n    prevents end users from inadvertently calling `create()` instead\n    of `createRecord()`. The store is still able to create instances\n    by calling the `_create()` method. To create an instance of a\n    `DS.Model` use [store.createRecord](DS.Store.html#method_createRecord).\n\n    @method create\n    @private\n    @static\n  */\n  create: function() {\n    throw new Ember.Error(\"You should not call `create` on a model. Instead, call `store.createRecord` with the attributes you would like to set.\");\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/model/model");minispade.register('ember-data/system/model/states', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\n/*\n  This file encapsulates the various states that a record can transition\n  through during its lifecycle.\n*/\n/**\n  ### State\n\n  Each record has a `currentState` property that explicitly tracks what\n  state a record is in at any given time. For instance, if a record is\n  newly created and has not yet been sent to the adapter to be saved,\n  it would be in the `root.loaded.created.uncommitted` state.  If a\n  record has had local modifications made to it that are in the\n  process of being saved, the record would be in the\n  `root.loaded.updated.inFlight` state. (These state paths will be\n  explained in more detail below.)\n\n  Events are sent by the record or its store to the record's\n  `currentState` property. How the state reacts to these events is\n  dependent on which state it is in. In some states, certain events\n  will be invalid and will cause an exception to be raised.\n\n  States are hierarchical and every state is a substate of the\n  `RootState`. For example, a record can be in the\n  `root.deleted.uncommitted` state, then transition into the\n  `root.deleted.inFlight` state. If a child state does not implement\n  an event handler, the state manager will attempt to invoke the event\n  on all parent states until the root state is reached. The state\n  hierarchy of a record is described in terms of a path string. You\n  can determine a record's current state by getting the state's\n  `stateName` property:\n\n  ```javascript\n  record.get('currentState.stateName');\n  //=> \"root.created.uncommitted\"\n   ```\n\n  The hierarchy of valid states that ship with ember data looks like\n  this:\n\n  ```text\n  * root\n    * deleted\n      * saved\n      * uncommitted\n      * inFlight\n    * empty\n    * loaded\n      * created\n        * uncommitted\n        * inFlight\n      * saved\n      * updated\n        * uncommitted\n        * inFlight\n    * loading\n  ```\n\n  The `DS.Model` states are themselves stateless. What we mean is\n  that, the hierarchical states that each of *those* points to is a\n  shared data structure. For performance reasons, instead of each\n  record getting its own copy of the hierarchy of states, each record\n  points to this global, immutable shared instance. How does a state\n  know which record it should be acting on? We pass the record\n  instance into the state's event handlers as the first argument.\n\n  The record passed as the first parameter is where you should stash\n  state about the record if needed; you should never store data on the state\n  object itself.\n\n  ### Events and Flags\n\n  A state may implement zero or more events and flags.\n\n  #### Events\n\n  Events are named functions that are invoked when sent to a record. The\n  record will first look for a method with the given name on the\n  current state. If no method is found, it will search the current\n  state's parent, and then its grandparent, and so on until reaching\n  the top of the hierarchy. If the root is reached without an event\n  handler being found, an exception will be raised. This can be very\n  helpful when debugging new features.\n\n  Here's an example implementation of a state with a `myEvent` event handler:\n\n  ```javascript\n  aState: DS.State.create({\n    myEvent: function(manager, param) {\n      console.log(\"Received myEvent with\", param);\n    }\n  })\n  ```\n\n  To trigger this event:\n\n  ```javascript\n  record.send('myEvent', 'foo');\n  //=> \"Received myEvent with foo\"\n  ```\n\n  Note that an optional parameter can be sent to a record's `send()` method,\n  which will be passed as the second parameter to the event handler.\n\n  Events should transition to a different state if appropriate. This can be\n  done by calling the record's `transitionTo()` method with a path to the\n  desired state. The state manager will attempt to resolve the state path\n  relative to the current state. If no state is found at that path, it will\n  attempt to resolve it relative to the current state's parent, and then its\n  parent, and so on until the root is reached. For example, imagine a hierarchy\n  like this:\n\n      * created\n        * uncommitted <-- currentState\n        * inFlight\n      * updated\n        * inFlight\n\n  If we are currently in the `uncommitted` state, calling\n  `transitionTo('inFlight')` would transition to the `created.inFlight` state,\n  while calling `transitionTo('updated.inFlight')` would transition to\n  the `updated.inFlight` state.\n\n  Remember that *only events* should ever cause a state transition. You should\n  never call `transitionTo()` from outside a state's event handler. If you are\n  tempted to do so, create a new event and send that to the state manager.\n\n  #### Flags\n\n  Flags are Boolean values that can be used to introspect a record's current\n  state in a more user-friendly way than examining its state path. For example,\n  instead of doing this:\n\n  ```javascript\n  var statePath = record.get('stateManager.currentPath');\n  if (statePath === 'created.inFlight') {\n    doSomething();\n  }\n  ```\n\n  You can say:\n\n  ```javascript\n  if (record.get('isNew') && record.get('isSaving')) {\n    doSomething();\n  }\n  ```\n\n  If your state does not set a value for a given flag, the value will\n  be inherited from its parent (or the first place in the state hierarchy\n  where it is defined).\n\n  The current set of flags are defined below. If you want to add a new flag,\n  in addition to the area below, you will also need to declare it in the\n  `DS.Model` class.\n\n\n   * [isEmpty](DS.Model.html#property_isEmpty)\n   * [isLoading](DS.Model.html#property_isLoading)\n   * [isLoaded](DS.Model.html#property_isLoaded)\n   * [isDirty](DS.Model.html#property_isDirty)\n   * [isSaving](DS.Model.html#property_isSaving)\n   * [isDeleted](DS.Model.html#property_isDeleted)\n   * [isNew](DS.Model.html#property_isNew)\n   * [isValid](DS.Model.html#property_isValid)\n\n  @namespace DS\n  @class RootState\n*/\n\nvar hasDefinedProperties = function(object) {\n  // Ignore internal property defined by simulated `Ember.create`.\n  var names = Ember.keys(object);\n  var i, l, name;\n  for (i = 0, l = names.length; i < l; i++ ) {\n    name = names[i];\n    if (object.hasOwnProperty(name) && object[name]) { return true; }\n  }\n\n  return false;\n};\n\nvar didSetProperty = function(record, context) {\n  if (context.value === context.originalValue) {\n    delete record._attributes[context.name];\n    record.send('propertyWasReset', context.name);\n  } else if (context.value !== context.oldValue) {\n    record.send('becomeDirty');\n  }\n\n  record.updateRecordArraysLater();\n};\n\n// Implementation notes:\n//\n// Each state has a boolean value for all of the following flags:\n//\n// * isLoaded: The record has a populated `data` property. When a\n//   record is loaded via `store.find`, `isLoaded` is false\n//   until the adapter sets it. When a record is created locally,\n//   its `isLoaded` property is always true.\n// * isDirty: The record has local changes that have not yet been\n//   saved by the adapter. This includes records that have been\n//   created (but not yet saved) or deleted.\n// * isSaving: The record has been committed, but\n//   the adapter has not yet acknowledged that the changes have\n//   been persisted to the backend.\n// * isDeleted: The record was marked for deletion. When `isDeleted`\n//   is true and `isDirty` is true, the record is deleted locally\n//   but the deletion was not yet persisted. When `isSaving` is\n//   true, the change is in-flight. When both `isDirty` and\n//   `isSaving` are false, the change has persisted.\n// * isError: The adapter reported that it was unable to save\n//   local changes to the backend. This may also result in the\n//   record having its `isValid` property become false if the\n//   adapter reported that server-side validations failed.\n// * isNew: The record was created on the client and the adapter\n//   did not yet report that it was successfully saved.\n// * isValid: No client-side validations have failed and the\n//   adapter did not report any server-side validation failures.\n\n// The dirty state is a abstract state whose functionality is\n// shared between the `created` and `updated` states.\n//\n// The deleted state shares the `isDirty` flag with the\n// subclasses of `DirtyState`, but with a very different\n// implementation.\n//\n// Dirty states have three child states:\n//\n// `uncommitted`: the store has not yet handed off the record\n//   to be saved.\n// `inFlight`: the store has handed off the record to be saved,\n//   but the adapter has not yet acknowledged success.\n// `invalid`: the record has invalid information and cannot be\n//   send to the adapter yet.\nvar DirtyState = {\n  initialState: 'uncommitted',\n\n  // FLAGS\n  isDirty: true,\n\n  // SUBSTATES\n\n  // When a record first becomes dirty, it is `uncommitted`.\n  // This means that there are local pending changes, but they\n  // have not yet begun to be saved, and are not invalid.\n  uncommitted: {\n    // EVENTS\n    didSetProperty: didSetProperty,\n\n    propertyWasReset: function(record, name) {\n      var stillDirty = false;\n\n      for (var prop in record._attributes) {\n        stillDirty = true;\n        break;\n      }\n\n      if (!stillDirty) { record.send('rolledBack'); }\n    },\n\n    pushedData: Ember.K,\n\n    becomeDirty: Ember.K,\n\n    willCommit: function(record) {\n      record.transitionTo('inFlight');\n    },\n\n    reloadRecord: function(record, resolve) {\n      resolve(get(record, 'store').reloadRecord(record));\n    },\n\n    rolledBack: function(record) {\n      record.transitionTo('loaded.saved');\n    },\n\n    becameInvalid: function(record) {\n      record.transitionTo('invalid');\n    },\n\n    rollback: function(record) {\n      record.rollback();\n    }\n  },\n\n  // Once a record has been handed off to the adapter to be\n  // saved, it is in the 'in flight' state. Changes to the\n  // record cannot be made during this window.\n  inFlight: {\n    // FLAGS\n    isSaving: true,\n\n    // EVENTS\n    didSetProperty: didSetProperty,\n    becomeDirty: Ember.K,\n    pushedData: Ember.K,\n\n    // TODO: More robust semantics around save-while-in-flight\n    willCommit: Ember.K,\n\n    didCommit: function(record) {\n      var dirtyType = get(this, 'dirtyType');\n\n      record.transitionTo('saved');\n      record.send('invokeLifecycleCallbacks', dirtyType);\n    },\n\n    becameInvalid: function(record, errors) {\n      set(record, 'errors', errors);\n\n      record.transitionTo('invalid');\n      record.send('invokeLifecycleCallbacks');\n    },\n\n    becameError: function(record) {\n      record.transitionTo('uncommitted');\n      record.triggerLater('becameError', record);\n    }\n  },\n\n  // A record is in the `invalid` state when its client-side\n  // invalidations have failed, or if the adapter has indicated\n  // the the record failed server-side invalidations.\n  invalid: {\n    // FLAGS\n    isValid: false,\n\n    // EVENTS\n    deleteRecord: function(record) {\n      record.transitionTo('deleted.uncommitted');\n      record.clearRelationships();\n    },\n\n    didSetProperty: function(record, context) {\n      var errors = get(record, 'errors'),\n          key = context.name;\n\n      set(errors, key, null);\n\n      if (!hasDefinedProperties(errors)) {\n        record.send('becameValid');\n      }\n\n      didSetProperty(record, context);\n    },\n\n    becomeDirty: Ember.K,\n\n    rollback: function(record) {\n      record.send('becameValid');\n      record.send('rollback');\n    },\n\n    becameValid: function(record) {\n      record.transitionTo('uncommitted');\n    },\n\n    invokeLifecycleCallbacks: function(record) {\n      record.triggerLater('becameInvalid', record);\n    }\n  }\n};\n\n// The created and updated states are created outside the state\n// chart so we can reopen their substates and add mixins as\n// necessary.\n\nfunction deepClone(object) {\n  var clone = {}, value;\n\n  for (var prop in object) {\n    value = object[prop];\n    if (value && typeof value === 'object') {\n      clone[prop] = deepClone(value);\n    } else {\n      clone[prop] = value;\n    }\n  }\n\n  return clone;\n}\n\nfunction mixin(original, hash) {\n  for (var prop in hash) {\n    original[prop] = hash[prop];\n  }\n\n  return original;\n}\n\nfunction dirtyState(options) {\n  var newState = deepClone(DirtyState);\n  return mixin(newState, options);\n}\n\nvar createdState = dirtyState({\n  dirtyType: 'created',\n\n  // FLAGS\n  isNew: true\n});\n\ncreatedState.uncommitted.rolledBack = function(record) {\n  record.transitionTo('deleted.saved');\n};\n\nvar updatedState = dirtyState({\n  dirtyType: 'updated'\n});\n\ncreatedState.uncommitted.deleteRecord = function(record) {\n  record.clearRelationships();\n  record.transitionTo('deleted.saved');\n};\n\ncreatedState.uncommitted.rollback = function(record) {\n  DirtyState.uncommitted.rollback.apply(this, arguments);\n  record.transitionTo('deleted.saved');\n};\n\nupdatedState.uncommitted.deleteRecord = function(record) {\n  record.transitionTo('deleted.uncommitted');\n  record.clearRelationships();\n};\n\nvar RootState = {\n  // FLAGS\n  isEmpty: false,\n  isLoading: false,\n  isLoaded: false,\n  isDirty: false,\n  isSaving: false,\n  isDeleted: false,\n  isNew: false,\n  isValid: true,\n\n  // DEFAULT EVENTS\n\n  // Trying to roll back if you're not in the dirty state\n  // doesn't change your state. For example, if you're in the\n  // in-flight state, rolling back the record doesn't move\n  // you out of the in-flight state.\n  rolledBack: Ember.K,\n\n  propertyWasReset: Ember.K,\n\n  // SUBSTATES\n\n  // A record begins its lifecycle in the `empty` state.\n  // If its data will come from the adapter, it will\n  // transition into the `loading` state. Otherwise, if\n  // the record is being created on the client, it will\n  // transition into the `created` state.\n  empty: {\n    isEmpty: true,\n\n    // EVENTS\n    loadingData: function(record, promise) {\n      record._loadingPromise = promise;\n      record.transitionTo('loading');\n    },\n\n    loadedData: function(record) {\n      record.transitionTo('loaded.created.uncommitted');\n\n      record.suspendRelationshipObservers(function() {\n        record.notifyPropertyChange('data');\n      });\n    },\n\n    pushedData: function(record) {\n      record.transitionTo('loaded.saved');\n      record.triggerLater('didLoad');\n    }\n  },\n\n  // A record enters this state when the store askes\n  // the adapter for its data. It remains in this state\n  // until the adapter provides the requested data.\n  //\n  // Usually, this process is asynchronous, using an\n  // XHR to retrieve the data.\n  loading: {\n    // FLAGS\n    isLoading: true,\n\n    exit: function(record) {\n      record._loadingPromise = null;\n    },\n\n    // EVENTS\n    pushedData: function(record) {\n      record.transitionTo('loaded.saved');\n      record.triggerLater('didLoad');\n      set(record, 'isError', false);\n    },\n\n    becameError: function(record) {\n      record.triggerLater('becameError', record);\n    },\n\n    notFound: function(record) {\n      record.transitionTo('empty');\n    }\n  },\n\n  // A record enters this state when its data is populated.\n  // Most of a record's lifecycle is spent inside substates\n  // of the `loaded` state.\n  loaded: {\n    initialState: 'saved',\n\n    // FLAGS\n    isLoaded: true,\n\n    // SUBSTATES\n\n    // If there are no local changes to a record, it remains\n    // in the `saved` state.\n    saved: {\n      setup: function(record) {\n        var attrs = record._attributes,\n            isDirty = false;\n\n        for (var prop in attrs) {\n          if (attrs.hasOwnProperty(prop)) {\n            isDirty = true;\n            break;\n          }\n        }\n\n        if (isDirty) {\n          record.adapterDidDirty();\n        }\n      },\n\n      // EVENTS\n      didSetProperty: didSetProperty,\n\n      pushedData: Ember.K,\n\n      becomeDirty: function(record) {\n        record.transitionTo('updated.uncommitted');\n      },\n\n      willCommit: function(record) {\n        record.transitionTo('updated.inFlight');\n      },\n\n      reloadRecord: function(record, resolve) {\n        resolve(get(record, 'store').reloadRecord(record));\n      },\n\n      deleteRecord: function(record) {\n        record.transitionTo('deleted.uncommitted');\n        record.clearRelationships();\n      },\n\n      unloadRecord: function(record) {\n        // clear relationships before moving to deleted state\n        // otherwise it fails\n        record.clearRelationships();\n        record.transitionTo('deleted.saved');\n      },\n\n      didCommit: function(record) {\n        record.send('invokeLifecycleCallbacks', get(record, 'lastDirtyType'));\n      },\n\n      // loaded.saved.notFound would be triggered by a failed\n      // `reload()` on an unchanged record\n      notFound: Ember.K\n\n    },\n\n    // A record is in this state after it has been locally\n    // created but before the adapter has indicated that\n    // it has been saved.\n    created: createdState,\n\n    // A record is in this state if it has already been\n    // saved to the server, but there are new local changes\n    // that have not yet been saved.\n    updated: updatedState\n  },\n\n  // A record is in this state if it was deleted from the store.\n  deleted: {\n    initialState: 'uncommitted',\n    dirtyType: 'deleted',\n\n    // FLAGS\n    isDeleted: true,\n    isLoaded: true,\n    isDirty: true,\n\n    // TRANSITIONS\n    setup: function(record) {\n      record.updateRecordArrays();\n    },\n\n    // SUBSTATES\n\n    // When a record is deleted, it enters the `start`\n    // state. It will exit this state when the record\n    // starts to commit.\n    uncommitted: {\n\n      // EVENTS\n\n      willCommit: function(record) {\n        record.transitionTo('inFlight');\n      },\n\n      rollback: function(record) {\n        record.rollback();\n      },\n\n      becomeDirty: Ember.K,\n      deleteRecord: Ember.K,\n\n      rolledBack: function(record) {\n        record.transitionTo('loaded.saved');\n      }\n    },\n\n    // After a record starts committing, but\n    // before the adapter indicates that the deletion\n    // has saved to the server, a record is in the\n    // `inFlight` substate of `deleted`.\n    inFlight: {\n      // FLAGS\n      isSaving: true,\n\n      // EVENTS\n\n      // TODO: More robust semantics around save-while-in-flight\n      willCommit: Ember.K,\n      didCommit: function(record) {\n        record.transitionTo('saved');\n\n        record.send('invokeLifecycleCallbacks');\n      },\n\n      becameError: function(record) {\n        record.transitionTo('uncommitted');\n        record.triggerLater('becameError', record);\n      }\n    },\n\n    // Once the adapter indicates that the deletion has\n    // been saved, the record enters the `saved` substate\n    // of `deleted`.\n    saved: {\n      // FLAGS\n      isDirty: false,\n\n      setup: function(record) {\n        var store = get(record, 'store');\n        store.dematerializeRecord(record);\n      },\n\n      invokeLifecycleCallbacks: function(record) {\n        record.triggerLater('didDelete', record);\n        record.triggerLater('didCommit', record);\n      }\n    }\n  },\n\n  invokeLifecycleCallbacks: function(record, dirtyType) {\n    if (dirtyType === 'created') {\n      record.triggerLater('didCreate', record);\n    } else {\n      record.triggerLater('didUpdate', record);\n    }\n\n    record.triggerLater('didCommit', record);\n  }\n};\n\nfunction wireState(object, parent, name) {\n  /*jshint proto:true*/\n  // TODO: Use Object.create and copy instead\n  object = mixin(parent ? Ember.create(parent) : {}, object);\n  object.parentState = parent;\n  object.stateName = name;\n\n  for (var prop in object) {\n    if (!object.hasOwnProperty(prop) || prop === 'parentState' || prop === 'stateName') { continue; }\n    if (typeof object[prop] === 'object') {\n      object[prop] = wireState(object[prop], object, name + \".\" + prop);\n    }\n  }\n\n  return object;\n}\n\nRootState = wireState(RootState, null, \"root\");\n\nDS.RootState = RootState;\n\n})();\n//@ sourceURL=ember-data/system/model/states");minispade.register('ember-data/system/record_array_manager', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar forEach = Ember.EnumerableUtils.forEach;\n\n/**\n  @class RecordArrayManager\n  @namespace DS\n  @private\n  @extends Ember.Object\n*/\nDS.RecordArrayManager = Ember.Object.extend({\n  init: function() {\n    this.filteredRecordArrays = Ember.MapWithDefault.create({\n      defaultValue: function() { return []; }\n    });\n\n    this.changedRecords = [];\n  },\n\n  recordDidChange: function(record) {\n    this.changedRecords.push(record);\n    once(this, this.updateRecordArrays);\n  },\n\n  recordArraysForRecord: function(record) {\n    record._recordArrays = record._recordArrays || Ember.OrderedSet.create();\n    return record._recordArrays;\n  },\n\n  /**\n    This method is invoked whenever data is loaded into the store by the\n    adapter or updated by the adapter, or when a record has changed.\n\n    It updates all record arrays that a record belongs to.\n\n    To avoid thrashing, it only runs at most once per run loop.\n\n    @method updateRecordArrays\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArrays: function() {\n    forEach(this.changedRecords, function(record) {\n      if (get(record, 'isDeleted')) {\n        this._recordWasDeleted(record);\n      } else {\n        this._recordWasChanged(record);\n      }\n    }, this);\n\n    this.changedRecords = [];\n  },\n\n  _recordWasDeleted: function (record) {\n    var recordArrays = record._recordArrays;\n\n    if (!recordArrays) { return; }\n\n    forEach(recordArrays, function(array) {\n      array.removeRecord(record);\n    });\n  },\n\n  _recordWasChanged: function (record) {\n    var type = record.constructor,\n        recordArrays = this.filteredRecordArrays.get(type),\n        filter;\n\n    forEach(recordArrays, function(array) {\n      filter = get(array, 'filterFunction');\n      this.updateRecordArray(array, filter, type, record);\n    }, this);\n\n    // loop through all manyArrays containing an unloaded copy of this\n    // clientId and notify them that the record was loaded.\n    var manyArrays = record._loadingRecordArrays;\n\n    if (manyArrays) {\n      for (var i=0, l=manyArrays.length; i<l; i++) {\n        manyArrays[i].loadedRecord();\n      }\n\n      record._loadingRecordArrays = [];\n    }\n  },\n\n  /**\n    Update an individual filter.\n\n    @method updateRecordArray\n    @param {DS.FilteredRecordArray} array\n    @param {Function} filter\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArray: function(array, filter, type, record) {\n    var shouldBeInArray;\n\n    if (!filter) {\n      shouldBeInArray = true;\n    } else {\n      shouldBeInArray = filter(record);\n    }\n\n    var recordArrays = this.recordArraysForRecord(record);\n\n    if (shouldBeInArray) {\n      recordArrays.add(array);\n      array.addRecord(record);\n    } else if (!shouldBeInArray) {\n      recordArrays.remove(array);\n      array.removeRecord(record);\n    }\n  },\n\n  /**\n    This method is invoked if the `filterFunction` property is\n    changed on a `DS.FilteredRecordArray`.\n\n    It essentially re-runs the filter from scratch. This same\n    method is invoked when the filter is created in th first place.\n\n    @method updateFilter\n    @param array\n    @param type\n    @param filter\n  */\n  updateFilter: function(array, type, filter) {\n    var typeMap = this.store.typeMapFor(type),\n        records = typeMap.records, record;\n\n    for (var i=0, l=records.length; i<l; i++) {\n      record = records[i];\n\n      if (!get(record, 'isDeleted') && !get(record, 'isEmpty')) {\n        this.updateRecordArray(array, filter, type, record);\n      }\n    }\n  },\n\n  /**\n    Create a `DS.ManyArray` for a type and list of record references, and index\n    the `ManyArray` under each reference. This allows us to efficiently remove\n    records from `ManyArray`s when they are deleted.\n\n    @method createManyArray\n    @param {Class} type\n    @param {Array} references\n    @return {DS.ManyArray}\n  */\n  createManyArray: function(type, records) {\n    var manyArray = DS.ManyArray.create({\n      type: type,\n      content: records,\n      store: this.store\n    });\n\n    forEach(records, function(record) {\n      var arrays = this.recordArraysForRecord(record);\n      arrays.add(manyArray);\n    }, this);\n\n    return manyArray;\n  },\n\n  /**\n    Register a RecordArray for a given type to be backed by\n    a filter function. This will cause the array to update\n    automatically when records of that type change attribute\n    values or states.\n\n    @method registerFilteredRecordArray\n    @param {DS.RecordArray} array\n    @param {Class} type\n    @param {Function} filter\n  */\n  registerFilteredRecordArray: function(array, type, filter) {\n    var recordArrays = this.filteredRecordArrays.get(type);\n    recordArrays.push(array);\n\n    this.updateFilter(array, type, filter);\n  },\n\n  // Internally, we maintain a map of all unloaded IDs requested by\n  // a ManyArray. As the adapter loads data into the store, the\n  // store notifies any interested ManyArrays. When the ManyArray's\n  // total number of loading records drops to zero, it becomes\n  // `isLoaded` and fires a `didLoad` event.\n  registerWaitingRecordArray: function(record, array) {\n    var loadingRecordArrays = record._loadingRecordArrays || [];\n    loadingRecordArrays.push(array);\n    record._loadingRecordArrays = loadingRecordArrays;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_array_manager");minispade.register('ember-data/system/record_arrays', "(function() {/**\n  @module ember-data\n*/\nminispade.require('ember-data/system/record_arrays/record_array');\nminispade.require('ember-data/system/record_arrays/filtered_record_array');\nminispade.require('ember-data/system/record_arrays/adapter_populated_record_array');\nminispade.require('ember-data/system/record_arrays/many_array');\n\n})();\n//@ sourceURL=ember-data/system/record_arrays");minispade.register('ember-data/system/record_arrays/adapter_populated_record_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  @class AdapterPopulatedRecordArray\n  @namespace DS\n  @extends DS.RecordArray\n*/\nDS.AdapterPopulatedRecordArray = DS.RecordArray.extend({\n  query: null,\n\n  replace: function() {\n    var type = get(this, 'type').toString();\n    throw new Error(\"The result of a server query (on \" + type + \") is immutable.\");\n  },\n\n  load: function(data) {\n    var store = get(this, 'store'),\n        type = get(this, 'type'),\n        records = store.pushMany(type, data),\n        meta = store.metadataFor(type);\n\n    this.setProperties({\n      content: Ember.A(records),\n      isLoaded: true,\n      meta: meta\n    });\n\n    // TODO: does triggering didLoad event should be the last action of the runLoop?\n    Ember.run.once(this, 'trigger', 'didLoad');\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/adapter_populated_record_array");minispade.register('ember-data/system/record_arrays/filtered_record_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get;\n\n/**\n  @class FilteredRecordArray\n  @namespace DS\n  @extends DS.RecordArray\n*/\nDS.FilteredRecordArray = DS.RecordArray.extend({\n  filterFunction: null,\n  isLoaded: true,\n\n  replace: function() {\n    var type = get(this, 'type').toString();\n    throw new Error(\"The result of a client-side filter (on \" + type + \") is immutable.\");\n  },\n\n  updateFilter: Ember.observer(function() {\n    var manager = get(this, 'manager');\n    manager.updateFilter(this, get(this, 'type'), get(this, 'filterFunction'));\n  }, 'filterFunction')\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/filtered_record_array");minispade.register('ember-data/system/record_arrays/many_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar map = Ember.EnumerableUtils.map;\n\n/**\n  A `ManyArray` is a `RecordArray` that represents the contents of a has-many\n  relationship.\n\n  The `ManyArray` is instantiated lazily the first time the relationship is\n  requested.\n\n  ### Inverses\n\n  Often, the relationships in Ember Data applications will have\n  an inverse. For example, imagine the following models are\n  defined:\n\n  ```javascript\n  App.Post = DS.Model.extend({\n    comments: DS.hasMany('comment')\n  });\n\n  App.Comment = DS.Model.extend({\n    post: DS.belongsTo('post')\n  });\n  ```\n\n  If you created a new instance of `App.Post` and added\n  a `App.Comment` record to its `comments` has-many\n  relationship, you would expect the comment's `post`\n  property to be set to the post that contained\n  the has-many.\n\n  We call the record to which a relationship belongs the\n  relationship's _owner_.\n\n  @class ManyArray\n  @namespace DS\n  @extends DS.RecordArray\n*/\nDS.ManyArray = DS.RecordArray.extend({\n  init: function() {\n    this._super.apply(this, arguments);\n    this._changesToSync = Ember.OrderedSet.create();\n  },\n\n  /**\n    The property name of the relationship\n\n    @property {String} name\n    @private\n  */\n  name: null,\n\n  /**\n    The record to which this relationship belongs.\n\n    @property {DS.Model} owner\n    @private\n  */\n  owner: null,\n\n  /**\n    `true` if the relationship is polymorphic, `false` otherwise.\n\n    @property {Boolean} isPolymorphic\n    @private\n  */\n  isPolymorphic: false,\n\n  // LOADING STATE\n\n  isLoaded: false,\n\n  /**\n    Used for async `hasMany` arrays\n    to keep track of when they will resolve.\n\n    @property {Ember.RSVP.Promise} promise\n    @private\n  */\n  promise: null,\n\n  /**\n    @method loadingRecordsCount\n    @param {Number} count\n    @private\n  */\n  loadingRecordsCount: function(count) {\n    this.loadingRecordsCount = count;\n  },\n\n  /**\n    @method loadedRecord\n    @private\n  */\n  loadedRecord: function() {\n    this.loadingRecordsCount--;\n    if (this.loadingRecordsCount === 0) {\n      set(this, 'isLoaded', true);\n      this.trigger('didLoad');\n    }\n  },\n\n  /**\n    @method fetch\n    @private\n  */\n  fetch: function() {\n    var records = get(this, 'content'),\n        store = get(this, 'store'),\n        owner = get(this, 'owner'),\n        resolver = Ember.RSVP.defer(\"DS: ManyArray#fetch \" + get(this, 'type'));\n\n    var unloadedRecords = records.filterProperty('isEmpty', true);\n    store.fetchMany(unloadedRecords, owner, resolver);\n  },\n\n  // Overrides Ember.Array's replace method to implement\n  replaceContent: function(index, removed, added) {\n    // Map the array of record objects into an array of  client ids.\n    added = map(added, function(record) {\n      Ember.assert(\"You cannot add '\" + record.constructor.typeKey + \"' records to this relationship (only '\" + this.type.typeKey + \"' allowed)\", !this.type || record instanceof this.type);\n      return record;\n    }, this);\n\n    this._super(index, removed, added);\n  },\n\n  arrangedContentDidChange: function() {\n    Ember.run.once(this, 'fetch');\n  },\n\n  arrayContentWillChange: function(index, removed, added) {\n    var owner = get(this, 'owner'),\n        name = get(this, 'name');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the first half of code that continues inside\n      // of arrayContentDidChange. It gets or creates a change from\n      // the child object, adds the current owner as the old\n      // parent if this is the first time the object was removed\n      // from a ManyArray, and sets `newParent` to null.\n      //\n      // Later, if the object is added to another ManyArray,\n      // the `arrayContentDidChange` will set `newParent` on\n      // the change.\n      for (var i=index; i<index+removed; i++) {\n        var record = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner, record, get(this, 'store'), {\n          parentType: owner.constructor,\n          changeType: \"remove\",\n          kind: \"hasMany\",\n          key: name\n        });\n\n        this._changesToSync.add(change);\n      }\n    }\n\n    return this._super.apply(this, arguments);\n  },\n\n  arrayContentDidChange: function(index, removed, added) {\n    this._super.apply(this, arguments);\n\n    var owner = get(this, 'owner'),\n        name = get(this, 'name'),\n        store = get(this, 'store');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the second half of code that started in\n      // `arrayContentWillChange`. It gets or creates a change\n      // from the child object, and adds the current owner as\n      // the new parent.\n      for (var i=index; i<index+added; i++) {\n        var record = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner, record, store, {\n          parentType: owner.constructor,\n          changeType: \"add\",\n          kind:\"hasMany\",\n          key: name\n        });\n        change.hasManyName = name;\n\n        this._changesToSync.add(change);\n      }\n\n      // We wait until the array has finished being\n      // mutated before syncing the OneToManyChanges created\n      // in arrayContentWillChange, so that the array\n      // membership test in the sync() logic operates\n      // on the final results.\n      this._changesToSync.forEach(function(change) {\n        change.sync();\n      });\n\n      this._changesToSync.clear();\n    }\n  },\n\n  /**\n    Create a child record within the owner\n\n    @method createRecord\n    @private\n    @param {Object} hash\n    @return {DS.Model} record\n  */\n  createRecord: function(hash) {\n    var owner = get(this, 'owner'),\n        store = get(owner, 'store'),\n        type = get(this, 'type'),\n        record;\n\n    Ember.assert(\"You cannot add '\" + type.typeKey + \"' records to this polymorphic relationship.\", !get(this, 'isPolymorphic'));\n\n    record = store.createRecord.call(store, type, hash);\n    this.pushObject(record);\n\n    return record;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/many_array");minispade.register('ember-data/system/record_arrays/record_array', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  A record array is an array that contains records of a certain type. The record\n  array materializes records as needed when they are retrieved for the first\n  time. You should not create record arrays yourself. Instead, an instance of\n  `DS.RecordArray` or its subclasses will be returned by your application's store\n  in response to queries.\n\n  @class RecordArray\n  @namespace DS\n  @extends Ember.ArrayProxy\n  @uses Ember.Evented\n*/\n\nDS.RecordArray = Ember.ArrayProxy.extend(Ember.Evented, {\n  /**\n    The model type contained by this record array.\n\n    @property type\n    @type DS.Model\n  */\n  type: null,\n\n  /**\n    The array of client ids backing the record array. When a\n    record is requested from the record array, the record\n    for the client id at the same index is materialized, if\n    necessary, by the store.\n\n    @property content\n    @private\n    @type Ember.Array\n  */\n  content: null,\n\n  /**\n    The flag to signal a `RecordArray` is currently loading data.\n\n    Example\n\n    ```javascript\n    var people = store.all(App.Person);\n    people.get('isLoaded'); // true\n    ```\n\n    @property isLoaded\n    @type Boolean\n  */\n  isLoaded: false,\n  /**\n    The flag to signal a `RecordArray` is currently loading data.\n\n    Example\n\n    ```javascript\n    var people = store.all(App.Person);\n    people.get('isUpdating'); // false\n    people.update();\n    people.get('isUpdating'); // true\n    ```\n\n    @property isUpdating\n    @type Boolean\n  */\n  isUpdating: false,\n\n  /**\n    The store that created this record array.\n\n    @property store\n    @private\n    @type DS.Store\n  */\n  store: null,\n\n  /**\n    Retrieves an object from the content by index.\n\n    @method objectAtContent\n    @private\n    @param {Number} index\n    @return {DS.Model} record\n  */\n  objectAtContent: function(index) {\n    var content = get(this, 'content');\n\n    return content.objectAt(index);\n  },\n\n  /**\n    Used to get the latest version of all of the records in this array\n    from the adapter.\n\n    Example\n\n    ```javascript\n    var people = store.all(App.Person);\n    people.get('isUpdating'); // false\n    people.update();\n    people.get('isUpdating'); // true\n    ```\n\n    @method update\n  */\n  update: function() {\n    if (get(this, 'isUpdating')) { return; }\n\n    var store = get(this, 'store'),\n        type = get(this, 'type');\n\n    store.fetchAll(type, this);\n  },\n\n  /**\n    Adds a record to the `RecordArray`.\n\n    @method addRecord\n    @private\n    @param {DS.Model} record\n  */\n  addRecord: function(record) {\n    get(this, 'content').addObject(record);\n  },\n\n  /**\n    Removes a record to the `RecordArray`.\n\n    @method removeRecord\n    @private\n    @param {DS.Model} record\n  */\n  removeRecord: function(record) {\n    get(this, 'content').removeObject(record);\n  },\n\n  /**\n    Saves all of the records in the `RecordArray`.\n\n    Example\n\n    ```javascript\n    var messages = store.all(App.Message);\n    messages.forEach(function(message) {\n      message.set('hasBeenSeen', true);\n    });\n    messages.save();\n    ```\n\n    @method save\n    @return {DS.PromiseArray} promise\n  */\n  save: function() {\n    var promiseLabel = \"DS: RecordArray#save \" + get(this, 'type');\n    var promise = Ember.RSVP.all(this.invoke(\"save\"), promiseLabel).then(function(array) {\n      return Ember.A(array);\n    }, null, \"DS: RecordArray#save apply Ember.NativeArray\");\n\n    return DS.PromiseArray.create({ promise: promise });\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/record_array");minispade.register('ember-data/system/relationships', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/relationships/belongs_to\");\nminispade.require(\"ember-data/system/relationships/has_many\");\nminispade.require(\"ember-data/system/relationships/ext\");\n\n})();\n//@ sourceURL=ember-data/system/relationships");minispade.register('ember-data/system/relationships/belongs_to', "(function() {var get = Ember.get, set = Ember.set,\n    isNone = Ember.isNone;\n\n/**\n  @module ember-data\n*/\n\nfunction asyncBelongsTo(type, options, meta) {\n  return Ember.computed(function(key, value) {\n    var data = get(this, 'data'),\n        store = get(this, 'store'),\n        promiseLabel = \"DS: Async belongsTo \" + this + \" : \" + key;\n\n    if (arguments.length === 2) {\n      Ember.assert(\"You can only add a '\" + type + \"' record to this relationship\", !value || value instanceof store.modelFor(type));\n      return value === undefined ? null : DS.PromiseObject.create({ promise: Ember.RSVP.resolve(value, promiseLabel) });\n    }\n\n    var link = data.links && data.links[key],\n        belongsTo = data[key];\n\n    if(!isNone(belongsTo)) {\n      var promise = store.fetchRecord(belongsTo) || Ember.RSVP.resolve(belongsTo, promiseLabel);\n      return DS.PromiseObject.create({ promise: promise});\n    } else if (link) {\n      var resolver = Ember.RSVP.defer(\"DS: Async belongsTo (link) \" + this + \" : \" + key);\n      store.findBelongsTo(this, link, meta, resolver);\n      return DS.PromiseObject.create({ promise: resolver.promise });\n    } else {\n      return null;\n    }\n  }).property('data').meta(meta);\n}\n\n/**\n  `DS.belongsTo` is used to define One-To-One and One-To-Many\n  relationships on a [DS.Model](DS.Model.html).\n\n\n  `DS.belongsTo` takes an optional hash as a second parameter, currently\n  supported options are:\n\n  - `async`: A boolean value used to explicitly declare this to be an async relationship.\n  - `inverse`: A string used to identify the inverse property on a\n    related model in a One-To-Many relationship. See [Explicit Inverses](#toc_explicit-inverses)\n\n  #### One-To-One\n  To declare a one-to-one relationship between two models, use\n  `DS.belongsTo`:\n\n  ```javascript\n  App.User = DS.Model.extend({\n    profile: DS.belongsTo('profile')\n  });\n\n  App.Profile = DS.Model.extend({\n    user: DS.belongsTo('user')\n  });\n  ```\n\n  #### One-To-Many\n  To declare a one-to-many relationship between two models, use\n  `DS.belongsTo` in combination with `DS.hasMany`, like this:\n\n  ```javascript\n  App.Post = DS.Model.extend({\n    comments: DS.hasMany('comment')\n  });\n\n  App.Comment = DS.Model.extend({\n    post: DS.belongsTo('post')\n  });\n  ```\n\n  @namespace\n  @method belongsTo\n  @for DS\n  @param {String or DS.Model} type the model type of the relationship\n  @param {Object} options a hash of options\n  @return {Ember.computed} relationship\n*/\nDS.belongsTo = function(type, options) {\n  if (typeof type === 'object') {\n    options = type;\n    type = undefined;\n  } else {\n    Ember.assert(\"The first argument DS.belongsTo must be a model type or string, like DS.belongsTo(App.Person)\", !!type && (typeof type === 'string' || DS.Model.detect(type)));\n  }\n\n  options = options || {};\n\n  var meta = { type: type, isRelationship: true, options: options, kind: 'belongsTo' };\n\n  if (options.async) {\n    return asyncBelongsTo(type, options, meta);\n  }\n\n  return Ember.computed(function(key, value) {\n    var data = get(this, 'data'),\n        store = get(this, 'store'), belongsTo, typeClass;\n\n    if (typeof type === 'string') {\n      typeClass = store.modelFor(type);\n    } else {\n      typeClass = type;\n    }\n\n    if (arguments.length === 2) {\n      Ember.assert(\"You can only add a '\" + type + \"' record to this relationship\", !value || value instanceof typeClass);\n      return value === undefined ? null : value;\n    }\n\n    belongsTo = data[key];\n\n    if (isNone(belongsTo)) { return null; }\n\n    store.fetchRecord(belongsTo);\n\n    return belongsTo;\n  }).property('data').meta(meta);\n};\n\n/**\n  These observers observe all `belongsTo` relationships on the record. See\n  `relationships/ext` to see how these observers get their dependencies.\n\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopen({\n\n  /**\n    @method belongsToWillChange\n    @private\n    @static\n    @param record\n    @param key\n  */\n  belongsToWillChange: Ember.beforeObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var oldParent = get(record, key);\n\n      if (oldParent) {\n        var store = get(record, 'store'),\n            change = DS.RelationshipChange.createChange(record, oldParent, store, { key: key, kind: \"belongsTo\", changeType: \"remove\" });\n\n        change.sync();\n        this._changesToSync[key] = change;\n      }\n    }\n  }),\n\n  /**\n    @method belongsToDidChange\n    @private\n    @static\n    @param record\n    @param key\n  */\n  belongsToDidChange: Ember.immediateObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var newParent = get(record, key);\n\n      if (newParent) {\n        var store = get(record, 'store'),\n            change = DS.RelationshipChange.createChange(record, newParent, store, { key: key, kind: \"belongsTo\", changeType: \"add\" });\n\n        change.sync();\n      }\n    }\n\n    delete this._changesToSync[key];\n  })\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/belongs_to");minispade.register('ember-data/system/relationships/ext', "(function() {minispade.require(\"ember-inflector/system\");\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  @module ember-data\n*/\n\n/*\n  This file defines several extensions to the base `DS.Model` class that\n  add support for one-to-many relationships.\n*/\n\n/**\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopen({\n\n  /**\n    This Ember.js hook allows an object to be notified when a property\n    is defined.\n\n    In this case, we use it to be notified when an Ember Data user defines a\n    belongs-to relationship. In that case, we need to set up observers for\n    each one, allowing us to track relationship changes and automatically\n    reflect changes in the inverse has-many array.\n\n    This hook passes the class being set up, as well as the key and value\n    being defined. So, for example, when the user does this:\n\n    ```javascript\n    DS.Model.extend({\n      parent: DS.belongsTo('user')\n    });\n    ```\n\n    This hook would be called with \"parent\" as the key and the computed\n    property returned by `DS.belongsTo` as the value.\n\n    @method didDefineProperty\n    @param proto\n    @param key\n    @param value\n  */\n  didDefineProperty: function(proto, key, value) {\n    // Check if the value being set is a computed property.\n    if (value instanceof Ember.Descriptor) {\n\n      // If it is, get the metadata for the relationship. This is\n      // populated by the `DS.belongsTo` helper when it is creating\n      // the computed property.\n      var meta = value.meta();\n\n      if (meta.isRelationship && meta.kind === 'belongsTo') {\n        Ember.addObserver(proto, key, null, 'belongsToDidChange');\n        Ember.addBeforeObserver(proto, key, null, 'belongsToWillChange');\n      }\n\n      meta.parentType = proto.constructor;\n    }\n  }\n});\n\n/*\n  These DS.Model extensions add class methods that provide relationship\n  introspection abilities about relationships.\n\n  A note about the computed properties contained here:\n\n  **These properties are effectively sealed once called for the first time.**\n  To avoid repeatedly doing expensive iteration over a model's fields, these\n  values are computed once and then cached for the remainder of the runtime of\n  your application.\n\n  If your application needs to modify a class after its initial definition\n  (for example, using `reopen()` to add additional attributes), make sure you\n  do it before using your model with the store, which uses these properties\n  extensively.\n*/\n\nDS.Model.reopenClass({\n  /**\n    For a given relationship name, returns the model type of the relationship.\n\n    For example, if you define a model like this:\n\n   ```javascript\n    App.Post = DS.Model.extend({\n      comments: DS.hasMany('comment')\n    });\n   ```\n\n    Calling `App.Post.typeForRelationship('comments')` will return `App.Comment`.\n\n    @method typeForRelationship\n    @static\n    @param {String} name the name of the relationship\n    @return {subclass of DS.Model} the type of the relationship, or undefined\n  */\n  typeForRelationship: function(name) {\n    var relationship = get(this, 'relationshipsByName').get(name);\n    return relationship && relationship.type;\n  },\n\n  inverseFor: function(name) {\n    var inverseType = this.typeForRelationship(name);\n\n    if (!inverseType) { return null; }\n\n    var options = this.metaForProperty(name).options;\n\n    if (options.inverse === null) { return null; }\n    \n    var inverseName, inverseKind;\n\n    if (options.inverse) {\n      inverseName = options.inverse;\n      inverseKind = Ember.get(inverseType, 'relationshipsByName').get(inverseName).kind;\n    } else {\n      var possibleRelationships = findPossibleInverses(this, inverseType);\n\n      if (possibleRelationships.length === 0) { return null; }\n\n      Ember.assert(\"You defined the '\" + name + \"' relationship on \" + this + \", but multiple possible inverse relationships of type \" + this + \" were found on \" + inverseType + \". Look at http://emberjs.com/guides/models/defining-models/#toc_explicit-inverses for how to explicitly specify inverses\", possibleRelationships.length === 1);\n\n      inverseName = possibleRelationships[0].name;\n      inverseKind = possibleRelationships[0].kind;\n    }\n\n    function findPossibleInverses(type, inverseType, possibleRelationships) {\n      possibleRelationships = possibleRelationships || [];\n\n      var relationshipMap = get(inverseType, 'relationships');\n      if (!relationshipMap) { return; }\n\n      var relationships = relationshipMap.get(type);\n      if (relationships) {\n        possibleRelationships.push.apply(possibleRelationships, relationshipMap.get(type));\n      }\n\n      if (type.superclass) {\n        findPossibleInverses(type.superclass, inverseType, possibleRelationships);\n      }\n\n      return possibleRelationships;\n    }\n\n    return {\n      type: inverseType,\n      name: inverseName,\n      kind: inverseKind\n    };\n  },\n\n  /**\n    The model's relationships as a map, keyed on the type of the\n    relationship. The value of each entry is an array containing a descriptor\n    for each relationship with that type, describing the name of the relationship\n    as well as the type.\n\n    For example, given the following model definition:\n\n    ```javascript\n    App.Blog = DS.Model.extend({\n      users: DS.hasMany('user'),\n      owner: DS.belongsTo('user'),\n      posts: DS.hasMany('post')\n    });\n    ```\n\n    This computed property would return a map describing these\n    relationships, like this:\n\n    ```javascript\n    var relationships = Ember.get(App.Blog, 'relationships');\n    relationships.get(App.User);\n    //=> [ { name: 'users', kind: 'hasMany' },\n    //     { name: 'owner', kind: 'belongsTo' } ]\n    relationships.get(App.Post);\n    //=> [ { name: 'posts', kind: 'hasMany' } ]\n    ```\n\n    @property relationships\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  relationships: Ember.computed(function() {\n    var map = new Ember.MapWithDefault({\n      defaultValue: function() { return []; }\n    });\n\n    // Loop through each computed property on the class\n    this.eachComputedProperty(function(name, meta) {\n\n      // If the computed property is a relationship, add\n      // it to the map.\n      if (meta.isRelationship) {\n        if (typeof meta.type === 'string') {\n          meta.type = this.store.modelFor(meta.type);\n        }\n\n        var relationshipsForType = map.get(meta.type);\n\n        relationshipsForType.push({ name: name, kind: meta.kind });\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A hash containing lists of the model's relationships, grouped\n    by the relationship kind. For example, given a model with this\n    definition:\n\n    ```javascript\n    App.Blog = DS.Model.extend({\n      users: DS.hasMany('user'),\n      owner: DS.belongsTo('user'),\n\n      posts: DS.hasMany('post')\n    });\n    ```\n\n    This property would contain the following:\n\n    ```javascript\n    var relationshipNames = Ember.get(App.Blog, 'relationshipNames');\n    relationshipNames.hasMany;\n    //=> ['users', 'posts']\n    relationshipNames.belongsTo;\n    //=> ['owner']\n    ```\n\n    @property relationshipNames\n    @static\n    @type Object\n    @readOnly\n  */\n  relationshipNames: Ember.computed(function() {\n    var names = { hasMany: [], belongsTo: [] };\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        names[meta.kind].push(name);\n      }\n    });\n\n    return names;\n  }),\n\n  /**\n    An array of types directly related to a model. Each type will be\n    included once, regardless of the number of relationships it has with\n    the model.\n\n    For example, given a model with this definition:\n\n    ```javascript\n    App.Blog = DS.Model.extend({\n      users: DS.hasMany('user'),\n      owner: DS.belongsTo('user'),\n\n      posts: DS.hasMany('post')\n    });\n    ```\n\n    This property would contain the following:\n\n    ```javascript\n    var relatedTypes = Ember.get(App.Blog, 'relatedTypes');\n    //=> [ App.User, App.Post ]\n    ```\n\n    @property relatedTypes\n    @static\n    @type Ember.Array\n    @readOnly\n  */\n  relatedTypes: Ember.computed(function() {\n    var type,\n        types = Ember.A();\n\n    // Loop through each computed property on the class,\n    // and create an array of the unique types involved\n    // in relationships\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        type = meta.type;\n\n        if (typeof type === 'string') {\n          type = get(this, type, false) || this.store.modelFor(type);\n        }\n\n        Ember.assert(\"You specified a hasMany (\" + meta.type + \") on \" + meta.parentType + \" but \" + meta.type + \" was not found.\",  type);\n\n        if (!types.contains(type)) {\n          Ember.assert(\"Trying to sideload \" + name + \" on \" + this.toString() + \" but the type doesn't exist.\", !!type);\n          types.push(type);\n        }\n      }\n    });\n\n    return types;\n  }),\n\n  /**\n    A map whose keys are the relationships of a model and whose values are\n    relationship descriptors.\n\n    For example, given a model with this\n    definition:\n\n    ```javascript\n    App.Blog = DS.Model.extend({\n      users: DS.hasMany('user'),\n      owner: DS.belongsTo('user'),\n\n      posts: DS.hasMany('post')\n    });\n    ```\n\n    This property would contain the following:\n\n    ```javascript\n    var relationshipsByName = Ember.get(App.Blog, 'relationshipsByName');\n    relationshipsByName.get('users');\n    //=> { key: 'users', kind: 'hasMany', type: App.User }\n    relationshipsByName.get('owner');\n    //=> { key: 'owner', kind: 'belongsTo', type: App.User }\n    ```\n\n    @property relationshipsByName\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  relationshipsByName: Ember.computed(function() {\n    var map = Ember.Map.create(), type;\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        meta.key = name;\n        type = meta.type;\n\n        if (!type && meta.kind === 'hasMany') {\n          type = Ember.String.singularize(name);\n        } else if (!type) {\n          type = name;\n        }\n\n        if (typeof type === 'string') {\n          meta.type = this.store.modelFor(type);\n        }\n\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A map whose keys are the fields of the model and whose values are strings\n    describing the kind of the field. A model's fields are the union of all of its\n    attributes and relationships.\n\n    For example:\n\n    ```javascript\n\n    App.Blog = DS.Model.extend({\n      users: DS.hasMany('user'),\n      owner: DS.belongsTo('user'),\n\n      posts: DS.hasMany('post'),\n\n      title: DS.attr('string')\n    });\n\n    var fields = Ember.get(App.Blog, 'fields');\n    fields.forEach(function(field, kind) {\n      console.log(field, kind);\n    });\n\n    // prints:\n    // users, hasMany\n    // owner, belongsTo\n    // posts, hasMany\n    // title, attribute\n    ```\n\n    @property fields\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  fields: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        map.set(name, meta.kind);\n      } else if (meta.isAttribute) {\n        map.set(name, 'attribute');\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @method eachRelationship\n    @static\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    get(this, 'relationshipsByName').forEach(function(name, relationship) {\n      callback.call(binding, name, relationship);\n    });\n  },\n\n  /**\n    Given a callback, iterates over each of the types related to a model,\n    invoking the callback with the related type's class. Each type will be\n    returned just once, regardless of how many different relationships it has\n    with a model.\n\n    @method eachRelatedType\n    @static\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelatedType: function(callback, binding) {\n    get(this, 'relatedTypes').forEach(function(type) {\n      callback.call(binding, type);\n    });\n  }\n});\n\nDS.Model.reopen({\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @method eachRelationship\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    this.constructor.eachRelationship(callback, binding);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/ext");minispade.register('ember-data/system/relationships/has_many', "(function() {minispade.require(\"ember-data/system/model/model\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set, setProperties = Ember.setProperties;\n\nfunction asyncHasMany(type, options, meta) {\n  return Ember.computed(function(key, value) {\n    var relationship = this._relationships[key],\n        promiseLabel = \"DS: Async hasMany \" + this + \" : \" + key;\n\n    if (!relationship) {\n      var resolver = Ember.RSVP.defer(promiseLabel);\n      relationship = buildRelationship(this, key, options, function(store, data) {\n        var link = data.links && data.links[key];\n        var rel;\n        if (link) {\n          rel = store.findHasMany(this, link, meta, resolver);\n        } else {\n          rel = store.findMany(this, data[key], meta.type, resolver);\n        }\n        // cache the promise so we can use it\n        // when we come back and don't need to rebuild\n        // the relationship.\n        set(rel, 'promise', resolver.promise);\n        return rel;\n      });\n    }\n\n    var promise = relationship.get('promise').then(function() {\n      return relationship;\n    }, null, \"DS: Async hasMany records received\");\n\n    return DS.PromiseArray.create({ promise: promise });\n  }).property('data').meta(meta);\n}\n\nfunction buildRelationship(record, key, options, callback) {\n  var rels = record._relationships;\n\n  if (rels[key]) { return rels[key]; }\n\n  var data = get(record, 'data'),\n      store = get(record, 'store');\n\n  var relationship = rels[key] = callback.call(record, store, data);\n\n  return setProperties(relationship, {\n    owner: record, name: key, isPolymorphic: options.polymorphic\n  });\n}\n\nfunction hasRelationship(type, options) {\n  options = options || {};\n\n  var meta = { type: type, isRelationship: true, options: options, kind: 'hasMany' };\n\n  if (options.async) {\n    return asyncHasMany(type, options, meta);\n  }\n\n  return Ember.computed(function(key, value) {\n    return buildRelationship(this, key, options, function(store, data) {\n      var records = data[key];\n      Ember.assert(\"You looked up the '\" + key + \"' relationship on '\" + this + \"' but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async (`DS.hasMany({ async: true })`)\", Ember.A(records).everyProperty('isEmpty', false));\n      return store.findMany(this, data[key], meta.type);\n    });\n  }).property('data').meta(meta);\n}\n\n/**\n  `DS.hasMany` is used to define One-To-Many and Many-To-Many\n  relationships on a [DS.Model](DS.Model.html).\n\n  `DS.hasMany` takes an optional hash as a second parameter, currently\n  supported options are:\n\n  - `async`: A boolean value used to explicitly declare this to be an async relationship.\n  - `inverse`: A string used to identify the inverse property on a related model.\n\n  #### One-To-Many\n  To declare a one-to-many relationship between two models, use\n  `DS.belongsTo` in combination with `DS.hasMany`, like this:\n\n  ```javascript\n  App.Post = DS.Model.extend({\n    comments: DS.hasMany('comment')\n  });\n\n  App.Comment = DS.Model.extend({\n    post: DS.belongsTo('post')\n  });\n  ```\n\n  #### Many-To-Many\n  To declare a many-to-many relationship between two models, use\n  `DS.hasMany`:\n\n  ```javascript\n  App.Post = DS.Model.extend({\n    tags: DS.hasMany('tag')\n  });\n\n  App.Tag = DS.Model.extend({\n    posts: DS.hasMany('post')\n  });\n  ```\n\n  #### Explicit Inverses\n\n  Ember Data will do its best to discover which relationships map to\n  one another. In the one-to-many code above, for example, Ember Data\n  can figure out that changing the `comments` relationship should update\n  the `post` relationship on the inverse because post is the only\n  relationship to that model.\n\n  However, sometimes you may have multiple `belongsTo`/`hasManys` for the\n  same type. You can specify which property on the related model is\n  the inverse using `DS.hasMany`'s `inverse` option:\n\n  ```javascript\n  var belongsTo = DS.belongsTo,\n      hasMany = DS.hasMany;\n\n  App.Comment = DS.Model.extend({\n    onePost: belongsTo('post'),\n    twoPost: belongsTo('post'),\n    redPost: belongsTo('post'),\n    bluePost: belongsTo('post')\n  });\n\n  App.Post = DS.Model.extend({\n    comments: hasMany('comment', {\n      inverse: 'redPost'\n    })\n  });\n  ```\n\n  You can also specify an inverse on a `belongsTo`, which works how\n  you'd expect.\n\n  @namespace\n  @method hasMany\n  @for DS\n  @param {String or DS.Model} type the model type of the relationship\n  @param {Object} options a hash of options\n  @return {Ember.computed} relationship\n*/\nDS.hasMany = function(type, options) {\n  if (typeof type === 'object') {\n    options = type;\n    type = undefined;\n  }\n  return hasRelationship(type, options);\n};\n\n})();\n//@ sourceURL=ember-data/system/relationships/has_many");minispade.register('ember-data/system/store', "(function() {/*globals Ember*/\n/*jshint eqnull:true*/\nminispade.require(\"ember-data/system/record_arrays\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar isNone = Ember.isNone;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar indexOf = Ember.EnumerableUtils.indexOf;\nvar map = Ember.EnumerableUtils.map;\nvar resolve = Ember.RSVP.resolve;\nvar copy = Ember.copy;\n\n// Implementors Note:\n//\n//   The variables in this file are consistently named according to the following\n//   scheme:\n//\n//   * +id+ means an identifier managed by an external source, provided inside\n//     the data provided by that source. These are always coerced to be strings\n//     before being used internally.\n//   * +clientId+ means a transient numerical identifier generated at runtime by\n//     the data store. It is important primarily because newly created objects may\n//     not yet have an externally generated id.\n//   * +reference+ means a record reference object, which holds metadata about a\n//     record, even if it has not yet been fully materialized.\n//   * +type+ means a subclass of DS.Model.\n\n// Used by the store to normalize IDs entering the store.  Despite the fact\n// that developers may provide IDs as numbers (e.g., `store.find(Person, 1)`),\n// it is important that internally we use strings, since IDs may be serialized\n// and lose type information.  For example, Ember's router may put a record's\n// ID into the URL, and if we later try to deserialize that URL and find the\n// corresponding record, we will not know if it is a string or a number.\nvar coerceId = function(id) {\n  return id == null ? null : id+'';\n};\n\n/**\n  The store contains all of the data for records loaded from the server.\n  It is also responsible for creating instances of DS.Model that wrap\n  the individual data for a record, so that they can be bound to in your\n  Handlebars templates.\n\n  Define your application's store like this:\n\n  ```javascript\n  MyApp.Store = DS.Store.extend();\n  ```\n\n  Most Ember.js applications will only have a single `DS.Store` that is\n  automatically created by their `Ember.Application`.\n\n  You can retrieve models from the store in several ways. To retrieve a record\n  for a specific id, use `DS.Model`'s `find()` method:\n\n  ```javascript\n  var person = App.Person.find(123);\n  ```\n\n  If your application has multiple `DS.Store` instances (an unusual case), you can\n  specify which store should be used:\n\n  ```javascript\n  var person = store.find(App.Person, 123);\n  ```\n\n  In general, you should retrieve models using the methods on `DS.Model`; you should\n  rarely need to interact with the store directly.\n\n  By default, the store will talk to your backend using a standard REST mechanism.\n  You can customize how the store talks to your backend by specifying a custom adapter:\n\n  ```javascript\n   MyApp.store = DS.Store.create({\n     adapter: 'MyApp.CustomAdapter'\n   });\n   ```\n\n  You can learn more about writing a custom adapter by reading the `DS.Adapter`\n  documentation.\n\n  @class Store\n  @namespace DS\n  @extends Ember.Object\n*/\nDS.Store = Ember.Object.extend({\n\n  /**\n    @method init\n    @private\n  */\n  init: function() {\n    // internal bookkeeping; not observable\n    this.typeMaps = {};\n    this.recordArrayManager = DS.RecordArrayManager.create({\n      store: this\n    });\n    this._relationshipChanges = {};\n    this._pendingSave = [];\n  },\n\n  /**\n    The adapter to use to communicate to a backend server or other persistence layer.\n\n    This can be specified as an instance, class, or string.\n\n    If you want to specify `App.CustomAdapter` as a string, do:\n\n    ```js\n    adapter: 'custom'\n    ```\n\n    @property adapter\n    @default DS.RESTAdapter\n    @type {DS.Adapter|String}\n  */\n  adapter: '_rest',\n\n  /**\n    Returns a JSON representation of the record using a custom\n    type-specific serializer, if one exists.\n\n    The available options are:\n\n    * `includeId`: `true` if the record's ID should be included in\n      the JSON representation\n\n    @method serialize\n    @private\n    @param {DS.Model} record the record to serialize\n    @param {Object} options an options hash\n  */\n  serialize: function(record, options) {\n    return this.serializerFor(record.constructor.typeKey).serialize(record, options);\n  },\n\n  /**\n    This property returns the adapter, after resolving a possible\n    string key.\n\n    If the supplied `adapter` was a class, or a String property\n    path resolved to a class, this property will instantiate the\n    class.\n\n    This property is cacheable, so the same instance of a specified\n    adapter class should be used for the lifetime of the store.\n\n    @property defaultAdapter\n    @private\n    @returns DS.Adapter\n  */\n  defaultAdapter: Ember.computed('adapter', function() {\n    var adapter = get(this, 'adapter');\n\n    Ember.assert('You tried to set `adapter` property to an instance of `DS.Adapter`, where it should be a name or a factory', !(adapter instanceof DS.Adapter));\n\n    if (typeof adapter === 'string') {\n      adapter = this.container.lookup('adapter:' + adapter) || this.container.lookup('adapter:application') || this.container.lookup('adapter:_rest');\n    }\n\n    if (DS.Adapter.detect(adapter)) {\n      adapter = adapter.create({ container: this.container });\n    }\n\n    return adapter;\n  }),\n\n  // .....................\n  // . CREATE NEW RECORD .\n  // .....................\n\n  /**\n    Create a new record in the current store. The properties passed\n    to this method are set on the newly created record.\n\n    To create a new instance of `App.Post`:\n\n    ```js\n    store.createRecord('post', {\n      title: \"Rails is omakase\"\n    });\n    ```\n\n    @method createRecord\n    @param {String} type\n    @param {Object} properties a hash of properties to set on the\n      newly created record.\n    @returns DS.Model\n  */\n  createRecord: function(type, properties) {\n    type = this.modelFor(type);\n\n    properties = copy(properties) || {};\n\n    // If the passed properties do not include a primary key,\n    // give the adapter an opportunity to generate one. Typically,\n    // client-side ID generators will use something like uuid.js\n    // to avoid conflicts.\n\n    if (isNone(properties.id)) {\n      properties.id = this._generateId(type);\n    }\n\n    // Coerce ID to a string\n    properties.id = coerceId(properties.id);\n\n    var record = this.buildRecord(type, properties.id);\n\n    // Move the record out of its initial `empty` state into\n    // the `loaded` state.\n    record.loadedData();\n\n    // Set the properties specified on the record.\n    record.setProperties(properties);\n\n    return record;\n  },\n\n  /**\n    If possible, this method asks the adapter to generate an ID for\n    a newly created record.\n\n    @method generateId\n    @param {String} type\n    @returns String if the adapter can generate one, an ID\n  */\n  _generateId: function(type) {\n    var adapter = this.adapterFor(type);\n\n    if (adapter && adapter.generateIdForRecord) {\n      return adapter.generateIdForRecord(this);\n    }\n\n    return null;\n  },\n\n  // .................\n  // . DELETE RECORD .\n  // .................\n\n  /**\n    For symmetry, a record can be deleted via the store.\n\n    @method deleteRecord\n    @param {DS.Model} record\n  */\n  deleteRecord: function(record) {\n    record.deleteRecord();\n  },\n\n  /**\n    For symmetry, a record can be unloaded via the store.\n\n    @method unloadRecord\n    @param {DS.Model} record\n  */\n  unloadRecord: function(record) {\n    record.unloadRecord();\n  },\n\n  // ................\n  // . FIND RECORDS .\n  // ................\n\n  /**\n    This is the main entry point into finding records. The first parameter to\n    this method is the model's name as a string.\n\n    ---\n\n    To find a record by ID, pass the `id` as the second parameter:\n\n    ```javascript\n    store.find('person', 1);\n    ```\n\n    The `find` method will always return a **promise** that will be resolved\n    with the record. If the record was already in the store, the promise will\n    be resolved immediately. Otherwise, the store will ask the adapter's `find`\n    method to find the necessary data.\n\n    The `find` method will always resolve its promise with the same object for\n    a given type and `id`.\n\n    ---\n\n    To find all records for a type, call `find` with no additional parameters:\n\n    ```javascript\n    store.find('person');\n    ```\n\n    This will ask the adapter's `findAll` method to find the records for the\n    given type, and return a promise that will be resolved once the server\n    returns the values.\n\n    ---\n\n    To find a record by a query, call `find` with a hash as the second\n    parameter:\n\n    ```javascript\n    store.find(App.Person, { page: 1 });\n    ```\n\n    This will ask the adapter's `findQuery` method to find the records for\n    the query, and return a promise that will be resolved once the server\n    responds.\n\n    @method find\n    @param {DS.Model} type\n    @param {Object|String|Integer|null} id\n  */\n  find: function(type, id) {\n    if (id === undefined) {\n      return this.findAll(type);\n    }\n\n    // We are passed a query instead of an id.\n    if (Ember.typeOf(id) === 'object') {\n      return this.findQuery(type, id);\n    }\n\n    return this.findById(type, coerceId(id));\n  },\n\n  /**\n    This method returns a record for a given type and id combination.\n\n    @method findById\n    @private\n    @param type\n    @param id\n  */\n  findById: function(type, id) {\n    type = this.modelFor(type);\n\n    var record = this.recordForId(type, id);\n\n    var promise = this.fetchRecord(record) || resolve(record, \"DS: Store#findById \" + type + \" with id: \" + id);\n    return promiseObject(promise);\n  },\n\n  /**\n    This method makes a series of requests to the adapter's `find` method\n    and returns a promise that resolves once they are all loaded.\n\n    @private\n    @method findByIds\n    @param {String} type\n    @param {Array} ids\n    @returns Promise\n  */\n  findByIds: function(type, ids) {\n    var store = this;\n    var promiseLabel = \"DS: Store#findByIds \" + type;\n    return promiseArray(Ember.RSVP.all(map(ids, function(id) {\n      return store.findById(type, id);\n    })).then(Ember.A, null, \"DS: Store#findByIds of \" + type + \" complete\"));\n  },\n\n  /**\n    This method is called by `findById` if it discovers that a particular\n    type/id pair hasn't been loaded yet to kick off a request to the\n    adapter.\n\n    @method fetchRecord\n    @private\n    @param {DS.Model} record\n    @returns Promise\n  */\n  fetchRecord: function(record) {\n    if (isNone(record)) { return null; }\n    if (record._loadingPromise) { return record._loadingPromise; }\n    if (!get(record, 'isEmpty')) { return null; }\n\n    var type = record.constructor,\n        id = get(record, 'id'),\n        resolver = Ember.RSVP.defer(\"DS: Store#fetchRecord \" + record );\n\n    record.loadingData(resolver.promise);\n\n    var adapter = this.adapterFor(type);\n\n    Ember.assert(\"You tried to find a record but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to find a record but your adapter (for \" + type + \") does not implement 'find'\", adapter.find);\n\n    resolver.resolve(_find(adapter, this, type, id));\n\n    return resolver.promise;\n  },\n\n  /**\n    Get a record by a given type and ID without triggering a fetch.\n\n    This method will synchronously return the record if it's available.\n    Otherwise, it will return null.\n\n    ```js\n    var post = store.getById('post', 1);\n    ```\n\n    @method getById\n    @param type\n    @param id\n  */\n  getById: function(type, id) {\n    if (this.hasRecordForId(type, id)) {\n      return this.recordForId(type, id);\n    } else {\n      return null;\n    }\n  },\n\n  /**\n    This method is called by the record's `reload` method. The record's `reload`\n    passes in a resolver for the promise it returns.\n\n    This method calls the adapter's `find` method, which returns a promise. When\n    **that** promise resolves, `reloadRecord` will resolve the promise returned\n    by the record's `reload`.\n\n    @method reloadRecord\n    @private\n    @param {DS.Model} record\n    @param {Resolver} resolver\n  */\n  reloadRecord: function(record) {\n    var type = record.constructor,\n        adapter = this.adapterFor(type),\n        id = get(record, 'id');\n\n    Ember.assert(\"You cannot reload a record without an ID\", id);\n    Ember.assert(\"You tried to reload a record but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to reload a record but your adapter does not implement `find`\", adapter.find);\n\n    return _find(adapter, this, type, id);\n  },\n\n  /**\n    This method takes a list of records, groups the records by type,\n    converts the records into IDs, and then invokes the adapter's `findMany`\n    method.\n\n    The records are grouped by type to invoke `findMany` on adapters\n    for each unique type in records.\n\n    It is used both by a brand new relationship (via the `findMany`\n    method) or when the data underlying an existing relationship\n    changes.\n\n    @method fetchMany\n    @private\n    @param records\n    @param owner\n  */\n  fetchMany: function(records, owner, resolver) {\n    if (!records.length) { return; }\n\n    // Group By Type\n    var recordsByTypeMap = Ember.MapWithDefault.create({\n      defaultValue: function() { return Ember.A(); }\n    });\n\n    forEach(records, function(record) {\n      recordsByTypeMap.get(record.constructor).push(record);\n    });\n\n    forEach(recordsByTypeMap, function(type, records) {\n      var ids = records.mapProperty('id'),\n          adapter = this.adapterFor(type);\n\n      Ember.assert(\"You tried to load many records but you have no adapter (for \" + type + \")\", adapter);\n      Ember.assert(\"You tried to load many records but your adapter does not implement `findMany`\", adapter.findMany);\n\n      resolver.resolve(_findMany(adapter, this, type, ids, owner));\n    }, this);\n  },\n\n  /**\n    Returns true if a record for a given type and ID is already loaded.\n\n    @method hasRecordForId\n    @param {DS.Model} type\n    @param {String|Integer} id\n    @returns Boolean\n  */\n  hasRecordForId: function(type, id) {\n    id = coerceId(id);\n    type = this.modelFor(type);\n    return !!this.typeMapFor(type).idToRecord[id];\n  },\n\n  /**\n    Returns id record for a given type and ID. If one isn't already loaded,\n    it builds a new record and leaves it in the `empty` state.\n\n    @method recordForId\n    @param {String} type\n    @param {String|Integer} id\n    @returns DS.Model\n  */\n  recordForId: function(type, id) {\n    type = this.modelFor(type);\n\n    id = coerceId(id);\n\n    var record = this.typeMapFor(type).idToRecord[id];\n\n    if (!record) {\n      record = this.buildRecord(type, id);\n    }\n\n    return record;\n  },\n\n  /**\n    @method findMany\n    @private\n    @param {DS.Model} owner\n    @param {Array<DS.Model>} records\n    @param {String} type\n    @param {Resolver} resolver\n    @return DS.ManyArray\n  */\n  findMany: function(owner, records, type, resolver) {\n    type = this.modelFor(type);\n\n    records = Ember.A(records);\n\n    var unloadedRecords = records.filterProperty('isEmpty', true),\n        manyArray = this.recordArrayManager.createManyArray(type, records);\n\n    forEach(unloadedRecords, function(record) {\n      record.loadingData();\n    });\n\n    manyArray.loadingRecordsCount = unloadedRecords.length;\n\n    if (unloadedRecords.length) {\n      forEach(unloadedRecords, function(record) {\n        this.recordArrayManager.registerWaitingRecordArray(record, manyArray);\n      }, this);\n\n      this.fetchMany(unloadedRecords, owner, resolver);\n    } else {\n      if (resolver) { resolver.resolve(); }\n      manyArray.set('isLoaded', true);\n      Ember.run.once(manyArray, 'trigger', 'didLoad');\n    }\n\n    return manyArray;\n  },\n\n  /**\n    If a relationship was originally populated by the adapter as a link\n    (as opposed to a list of IDs), this method is called when the\n    relationship is fetched.\n\n    The link (which is usually a URL) is passed through unchanged, so the\n    adapter can make whatever request it wants.\n\n    The usual use-case is for the server to register a URL as a link, and\n    then use that URL in the future to make a request for the relationship.\n\n    @method findHasMany\n    @private\n    @param {DS.Model} owner\n    @param {any} link\n    @param {String} type\n    @param {Resolver} resolver\n    @return DS.ManyArray\n  */\n  findHasMany: function(owner, link, relationship, resolver) {\n    var adapter = this.adapterFor(owner.constructor);\n\n    Ember.assert(\"You tried to load a hasMany relationship but you have no adapter (for \" + owner.constructor + \")\", adapter);\n    Ember.assert(\"You tried to load a hasMany relationship from a specified `link` in the original payload but your adapter does not implement `findHasMany`\", adapter.findHasMany);\n\n    var records = this.recordArrayManager.createManyArray(relationship.type, Ember.A([]));\n    resolver.resolve(_findHasMany(adapter, this, owner, link, relationship));\n    return records;\n  },\n\n  findBelongsTo: function(owner, link, relationship, resolver) {\n    var adapter = this.adapterFor(owner.constructor);\n\n    Ember.assert(\"You tried to load a belongsTo relationship but you have no adapter (for \" + owner.constructor + \")\", adapter);\n    Ember.assert(\"You tried to load a belongsTo relationship from a specified `link` in the original payload but your adapter does not implement `findBelongsTo`\", adapter.findBelongsTo);\n\n    resolver.resolve(_findBelongsTo(adapter, this, owner, link, relationship));\n  },\n\n  /**\n    This method delegates a query to the adapter. This is the one place where\n    adapter-level semantics are exposed to the application.\n\n    Exposing queries this way seems preferable to creating an abstract query\n    language for all server-side queries, and then require all adapters to\n    implement them.\n\n    This method returns a promise, which is resolved with a `RecordArray`\n    once the server returns.\n\n    @method findQuery\n    @private\n    @param {String} type\n    @param {any} query an opaque query to be used by the adapter\n    @return Promise\n  */\n  findQuery: function(type, query) {\n    type = this.modelFor(type);\n\n    var array = DS.AdapterPopulatedRecordArray.create({\n      type: type,\n      query: query,\n      content: Ember.A(),\n      store: this\n    });\n\n    var adapter = this.adapterFor(type),\n        promiseLabel = \"DS: Store#findQuery \" + type,\n        resolver = Ember.RSVP.defer(promiseLabel);\n\n    Ember.assert(\"You tried to load a query but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load a query but your adapter does not implement `findQuery`\", adapter.findQuery);\n\n    resolver.resolve(_findQuery(adapter, this, type, query, array));\n\n    return promiseArray(resolver.promise);\n  },\n\n  /**\n    This method returns an array of all records adapter can find.\n    It triggers the adapter's `findAll` method to give it an opportunity to populate\n    the array with records of that type.\n\n    @method findAll\n    @private\n    @param {Class} type\n    @return {DS.AdapterPopulatedRecordArray}\n  */\n  findAll: function(type) {\n    type = this.modelFor(type);\n\n    return this.fetchAll(type, this.all(type));\n  },\n\n  /**\n    @method fetchAll\n    @private\n    @param type\n    @param array\n    @returns Promise\n  */\n  fetchAll: function(type, array) {\n    var adapter = this.adapterFor(type),\n        sinceToken = this.typeMapFor(type).metadata.since,\n        resolver = Ember.RSVP.defer(\"DS: Store#findAll \" + type);\n\n    set(array, 'isUpdating', true);\n\n    Ember.assert(\"You tried to load all records but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load all records but your adapter does not implement `findAll`\", adapter.findAll);\n\n    resolver.resolve(_findAll(adapter, this, type, sinceToken));\n\n    return promiseArray(resolver.promise);\n  },\n\n  /**\n    @method didUpdateAll\n    @param type\n  */\n  didUpdateAll: function(type) {\n    var findAllCache = this.typeMapFor(type).findAllCache;\n    set(findAllCache, 'isUpdating', false);\n  },\n\n  /**\n    This method returns a filtered array that contains all of the known records\n    for a given type.\n\n    Note that because it's just a filter, it will have any locally\n    created records of the type.\n\n    Also note that multiple calls to `all` for a given type will always\n    return the same RecordArray.\n\n    @method all\n    @param {Class} type\n    @return {DS.RecordArray}\n  */\n  all: function(type) {\n    type = this.modelFor(type);\n\n    var typeMap = this.typeMapFor(type),\n        findAllCache = typeMap.findAllCache;\n\n    if (findAllCache) { return findAllCache; }\n\n    var array = DS.RecordArray.create({\n      type: type,\n      content: Ember.A(),\n      store: this,\n      isLoaded: true\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type);\n\n    typeMap.findAllCache = array;\n    return array;\n  },\n\n\n  /**\n    This method unloads all of the known records for a given type.\n\n    @method unloadAll\n    @param {Class} type\n  */\n  unloadAll: function(type) {\n    type = this.modelFor(type);\n\n    var typeMap = this.typeMapFor(type),\n        records = typeMap.records, record;\n\n    while(record = records.pop()) {\n      record.unloadRecord();\n    }\n\n    typeMap.findAllCache = null;\n  },\n\n  /**\n    Takes a type and filter function, and returns a live RecordArray that\n    remains up to date as new records are loaded into the store or created\n    locally.\n\n    The callback function takes a materialized record, and returns true\n    if the record should be included in the filter and false if it should\n    not.\n\n    The filter function is called once on all records for the type when\n    it is created, and then once on each newly loaded or created record.\n\n    If any of a record's properties change, or if it changes state, the\n    filter function will be invoked again to determine whether it should\n    still be in the array.\n\n    Optionally you can pass a query which will be triggered at first. The\n    results returned by the server could then appear in the filter if they\n    match the filter function.\n\n    @method filter\n    @param {Class} type\n    @param {Object} query optional query\n    @param {Function} filter\n    @return {DS.PromiseArray}\n  */\n  filter: function(type, query, filter) {\n    var promise;\n\n    // allow an optional server query\n    if (arguments.length === 3) {\n      promise = this.findQuery(type, query);\n    } else if (arguments.length === 2) {\n      filter = query;\n    }\n\n    type = this.modelFor(type);\n\n    var array = DS.FilteredRecordArray.create({\n      type: type,\n      content: Ember.A(),\n      store: this,\n      manager: this.recordArrayManager,\n      filterFunction: filter\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type, filter);\n    promise = promise || resolve(array);\n\n    return promiseArray(promise.then(function() {\n      return array;\n    }, null, \"DS: Store#filter of \" + type));\n  },\n\n  /**\n    This method returns if a certain record is already loaded\n    in the store. Use this function to know beforehand if a find()\n    will result in a request or that it will be a cache hit.\n\n    @method recordIsLoaded\n    @param type\n    @param {string} id\n    @return {boolean}\n  */\n  recordIsLoaded: function(type, id) {\n    if (!this.hasRecordForId(type, id)) { return false; }\n    return !get(this.recordForId(type, id), 'isEmpty');\n  },\n\n  /**\n    This method returns the metadata for a specific type.\n\n    @method metadataFor\n    @param {string} type\n    @return {object}\n  */\n  metadataFor: function(type) {\n    type = this.modelFor(type);\n    return this.typeMapFor(type).metadata;\n  },\n\n  // ............\n  // . UPDATING .\n  // ............\n\n  /**\n    If the adapter updates attributes or acknowledges creation\n    or deletion, the record will notify the store to update its\n    membership in any filters.\n    To avoid thrashing, this method is invoked only once per\n\n    run loop per record.\n\n    @method dataWasUpdated\n    @private\n    @param {Class} type\n    @param {Number|String} clientId\n    @param {DS.Model} record\n  */\n  dataWasUpdated: function(type, record) {\n    this.recordArrayManager.recordDidChange(record);\n  },\n\n  // ..............\n  // . PERSISTING .\n  // ..............\n\n  /**\n    This method is called by `record.save`, and gets passed a\n    resolver for the promise that `record.save` returns.\n\n    It schedules saving to happen at the end of the run loop.\n\n    @method scheduleSave\n    @private\n    @param {DS.Model} record\n    @param {Resolver} resolver\n  */\n  scheduleSave: function(record, resolver) {\n    record.adapterWillCommit();\n    this._pendingSave.push([record, resolver]);\n    once(this, 'flushPendingSave');\n  },\n\n  /**\n    This method is called at the end of the run loop, and\n    flushes any records passed into `scheduleSave`\n\n    @method flushPendingSave\n    @private\n  */\n  flushPendingSave: function() {\n    var pending = this._pendingSave.slice();\n    this._pendingSave = [];\n\n    forEach(pending, function(tuple) {\n      var record = tuple[0], resolver = tuple[1],\n          adapter = this.adapterFor(record.constructor),\n          operation;\n\n      if (get(record, 'isNew')) {\n        operation = 'createRecord';\n      } else if (get(record, 'isDeleted')) {\n        operation = 'deleteRecord';\n      } else {\n        operation = 'updateRecord';\n      }\n\n      resolver.resolve(_commit(adapter, this, operation, record));\n    }, this);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is resolved.\n\n    If the data provides a server-generated ID, it will\n    update the record and the store's indexes.\n\n    @method didSaveRecord\n    @private\n    @param {DS.Model} record the in-flight record\n    @param {Object} data optional data (see above)\n  */\n  didSaveRecord: function(record, data) {\n    if (data) {\n      // normalize relationship IDs into records\n      data = normalizeRelationships(this, record.constructor, data, record);\n\n      this.updateId(record, data);\n    }\n\n    record.adapterDidCommit(data);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is rejected with a `DS.InvalidError`.\n\n    @method recordWasInvalid\n    @private\n    @param {DS.Model} record\n    @param {Object} errors\n  */\n  recordWasInvalid: function(record, errors) {\n    record.adapterDidInvalidate(errors);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is rejected (with anything other than a `DS.InvalidError`).\n\n    @method recordWasError\n    @private\n    @param {DS.Model} record\n  */\n  recordWasError: function(record) {\n    record.adapterDidError();\n  },\n\n  /**\n    When an adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    resolves with data, this method extracts the ID from the supplied\n    data.\n\n    @method updateId\n    @private\n    @param {DS.Model} record\n    @param {Object} data\n  */\n  updateId: function(record, data) {\n    var oldId = get(record, 'id'),\n        id = coerceId(data.id);\n\n    Ember.assert(\"An adapter cannot assign a new id to a record that already has an id. \" + record + \" had id: \" + oldId + \" and you tried to update it with \" + id + \". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\", oldId === null || id === oldId);\n\n    this.typeMapFor(record.constructor).idToRecord[id] = record;\n\n    set(record, 'id', id);\n  },\n\n  /**\n    Returns a map of IDs to client IDs for a given type.\n\n    @method typeMapFor\n    @private\n    @param type\n  */\n  typeMapFor: function(type) {\n    var typeMaps = get(this, 'typeMaps'),\n        guid = Ember.guidFor(type),\n        typeMap;\n\n    typeMap = typeMaps[guid];\n\n    if (typeMap) { return typeMap; }\n\n    typeMap = {\n      idToRecord: {},\n      records: [],\n      metadata: {}\n    };\n\n    typeMaps[guid] = typeMap;\n\n    return typeMap;\n  },\n\n  // ................\n  // . LOADING DATA .\n  // ................\n\n  /**\n    This internal method is used by `push`.\n\n    @method _load\n    @private\n    @param {DS.Model} type\n    @param {Object} data\n    @param {Boolean} partial the data should be merged into\n      the existing data, not replace it.\n  */\n  _load: function(type, data, partial) {\n    var id = coerceId(data.id),\n        record = this.recordForId(type, id);\n\n    record.setupData(data, partial);\n    this.recordArrayManager.recordDidChange(record);\n\n    return record;\n  },\n\n  /**\n    Returns a model class for a particular key. Used by\n    methods that take a type key (like `find`, `createRecord`,\n    etc.)\n\n    @method modelFor\n    @param {String or subclass of DS.Model} key\n    @returns {subclass of DS.Model}\n  */\n  modelFor: function(key) {\n    var factory;\n\n\n    if (typeof key === 'string') {\n      var normalizedKey = this.container.normalize('model:' + key);\n\n      factory = this.container.lookupFactory(normalizedKey);\n      if (!factory) { throw new Ember.Error(\"No model was found for '\" + key + \"'\"); }\n      factory.typeKey = normalizedKey.split(':', 2)[1];\n    } else {\n      // A factory already supplied.\n      factory = key;\n    }\n\n    factory.store = this;\n    return factory;\n  },\n\n  /**\n    Push some data for a given type into the store.\n\n    This method expects normalized data:\n\n    * The ID is a key named `id` (an ID is mandatory)\n    * The names of attributes are the ones you used in\n      your model's `DS.attr`s.\n    * Your relationships must be:\n      * represented as IDs or Arrays of IDs\n      * represented as model instances\n      * represented as URLs, under the `links` key\n\n    For this model:\n\n    ```js\n    App.Person = DS.Model.extend({\n      firstName: DS.attr(),\n      lastName: DS.attr(),\n\n      children: DS.hasMany('person')\n    });\n    ```\n\n    To represent the children as IDs:\n\n    ```js\n    {\n      id: 1,\n      firstName: \"Tom\",\n      lastName: \"Dale\",\n      children: [1, 2, 3]\n    }\n    ```\n\n    To represent the children relationship as a URL:\n\n    ```js\n    {\n      id: 1,\n      firstName: \"Tom\",\n      lastName: \"Dale\",\n      links: {\n        children: \"/people/1/children\"\n      }\n    }\n    ```\n\n    If you're streaming data or implementing an adapter,\n    make sure that you have converted the incoming data\n    into this form.\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records.\n\n    @method push\n    @param {String} type\n    @param {Object} data\n    @returns DS.Model the record that was created or\n      updated.\n  */\n  push: function(type, data, _partial) {\n    // _partial is an internal param used by `update`.\n    // If passed, it means that the data should be\n    // merged into the existing data, not replace it.\n\n    Ember.assert(\"You must include an `id` in a hash passed to `push`\", data.id != null);\n\n    type = this.modelFor(type);\n\n    // normalize relationship IDs into records\n    data = normalizeRelationships(this, type, data);\n\n    this._load(type, data, _partial);\n\n    return this.recordForId(type, data.id);\n  },\n\n  /**\n    Push some raw data into the store.\n\n    The data will be automatically deserialized using the\n    serializer for the `type` param.\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records.\n\n    You can push in more than one type of object at once.\n    All objects should be in the format expected by the\n    serializer.\n\n    ```js\n    App.ApplicationSerializer = DS.ActiveModelSerializer;\n\n    var pushData = {\n      posts: [\n        {id: 1, post_title: \"Great post\", comment_ids: [2]}\n      ],\n      comments: [\n        {id: 2, comment_body: \"Insightful comment\"}\n      ]\n    }\n\n    store.pushPayload('post', pushData);\n    ```\n\n    @method pushPayload\n    @param {String} type\n    @param {Object} payload\n  */\n\n  pushPayload: function (type, payload) {\n    var serializer;\n    if (!payload) {\n      payload = type;\n      serializer = defaultSerializer(this.container);\n      Ember.assert(\"You cannot use `store#pushPayload` without a type unless your default serializer defines `pushPayload`\", serializer.pushPayload);\n    } else {\n      serializer = this.serializerFor(type);\n    }\n    serializer.pushPayload(this, payload);\n  },\n\n  update: function(type, data) {\n    Ember.assert(\"You must include an `id` in a hash passed to `update`\", data.id != null);\n\n    return this.push(type, data, true);\n  },\n\n  /**\n    If you have an Array of normalized data to push,\n    you can call `pushMany` with the Array, and it will\n    call `push` repeatedly for you.\n\n    @method pushMany\n    @param {String} type\n    @param {Array} datas\n    @return {Array<DS.Model>}\n  */\n  pushMany: function(type, datas) {\n    return map(datas, function(data) {\n      return this.push(type, data);\n    }, this);\n  },\n\n  /**\n    If you have some metadata to set for a type\n    you can call `metaForType`.\n\n    @method metaForType\n    @param {String} type\n    @param {Object} metadata\n  */\n  metaForType: function(type, metadata) {\n    type = this.modelFor(type);\n\n    Ember.merge(this.typeMapFor(type).metadata, metadata);\n  },\n\n  /**\n    Build a brand new record for a given type, ID, and\n    initial data.\n\n    @method buildRecord\n    @private\n    @param {subclass of DS.Model} type\n    @param {String} id\n    @param {Object} data\n    @returns DS.Model\n  */\n  buildRecord: function(type, id, data) {\n    var typeMap = this.typeMapFor(type),\n        idToRecord = typeMap.idToRecord;\n\n    Ember.assert('The id ' + id + ' has already been used with another record of type ' + type.toString() + '.', !id || !idToRecord[id]);\n\n    // lookupFactory should really return an object that creates\n    // instances with the injections applied\n    var record = type._create({\n      id: id,\n      store: this,\n      container: this.container\n    });\n\n    if (data) {\n      record.setupData(data);\n    }\n\n    // if we're creating an item, this process will be done\n    // later, once the object has been persisted.\n    if (id) {\n      idToRecord[id] = record;\n    }\n\n    typeMap.records.push(record);\n\n    return record;\n  },\n\n  // ...............\n  // . DESTRUCTION .\n  // ...............\n\n  /**\n    When a record is destroyed, this un-indexes it and\n    removes it from any record arrays so it can be GCed.\n\n    @method dematerializeRecord\n    @private\n    @param {DS.Model} record\n  */\n  dematerializeRecord: function(record) {\n    var type = record.constructor,\n        typeMap = this.typeMapFor(type),\n        id = get(record, 'id');\n\n    record.updateRecordArrays();\n\n    if (id) {\n      delete typeMap.idToRecord[id];\n    }\n\n    var loc = indexOf(typeMap.records, record);\n    typeMap.records.splice(loc, 1);\n  },\n\n  // ........................\n  // . RELATIONSHIP CHANGES .\n  // ........................\n\n  addRelationshipChangeFor: function(childRecord, childKey, parentRecord, parentKey, change) {\n    var clientId = childRecord.clientId,\n        parentClientId = parentRecord ? parentRecord : parentRecord;\n    var key = childKey + parentKey;\n    var changes = this._relationshipChanges;\n    if (!(clientId in changes)) {\n      changes[clientId] = {};\n    }\n    if (!(parentClientId in changes[clientId])) {\n      changes[clientId][parentClientId] = {};\n    }\n    if (!(key in changes[clientId][parentClientId])) {\n      changes[clientId][parentClientId][key] = {};\n    }\n    changes[clientId][parentClientId][key][change.changeType] = change;\n  },\n\n  removeRelationshipChangeFor: function(clientRecord, childKey, parentRecord, parentKey, type) {\n    var clientId = clientRecord.clientId,\n        parentClientId = parentRecord ? parentRecord.clientId : parentRecord;\n    var changes = this._relationshipChanges;\n    var key = childKey + parentKey;\n    if (!(clientId in changes) || !(parentClientId in changes[clientId]) || !(key in changes[clientId][parentClientId])){\n      return;\n    }\n    delete changes[clientId][parentClientId][key][type];\n  },\n\n  relationshipChangePairsFor: function(record){\n    var toReturn = [];\n\n    if( !record ) { return toReturn; }\n\n    //TODO(Igor) What about the other side\n    var changesObject = this._relationshipChanges[record.clientId];\n    for (var objKey in changesObject){\n      if(changesObject.hasOwnProperty(objKey)){\n        for (var changeKey in changesObject[objKey]){\n          if(changesObject[objKey].hasOwnProperty(changeKey)){\n            toReturn.push(changesObject[objKey][changeKey]);\n          }\n        }\n      }\n    }\n    return toReturn;\n  },\n\n  // ......................\n  // . PER-TYPE ADAPTERS\n  // ......................\n\n  /**\n    Returns the adapter for a given type.\n\n    @method adapterFor\n    @private\n    @param {subclass of DS.Model} type\n    @returns DS.Adapter\n  */\n  adapterFor: function(type) {\n    var container = this.container, adapter;\n\n    if (container) {\n      adapter = container.lookup('adapter:' + type.typeKey) || container.lookup('adapter:application');\n    }\n\n    return adapter || get(this, 'defaultAdapter');\n  },\n\n  // ..............................\n  // . RECORD CHANGE NOTIFICATION .\n  // ..............................\n\n  /**\n    Returns an instance of the serializer for a given type. For\n    example, `serializerFor('person')` will return an instance of\n    `App.PersonSerializer`.\n\n    If no `App.PersonSerializer` is found, this method will look\n    for an `App.ApplicationSerializer` (the default serializer for\n    your entire application).\n\n    If no `App.ApplicationSerializer` is found, it will fall back\n    to an instance of `DS.JSONSerializer`.\n\n    @method serializerFor\n    @private\n    @param {String} type the record to serialize\n  */\n  serializerFor: function(type) {\n    type = this.modelFor(type);\n    var adapter = this.adapterFor(type);\n\n    return serializerFor(this.container, type.typeKey, adapter && adapter.defaultSerializer);\n  }\n});\n\nfunction normalizeRelationships(store, type, data, record) {\n  type.eachRelationship(function(key, relationship) {\n    // A link (usually a URL) was already provided in\n    // normalized form\n    if (data.links && data.links[key]) {\n      if (record && relationship.options.async) { record._relationships[key] = null; }\n      return;\n    }\n\n    var kind = relationship.kind,\n        value = data[key];\n\n    if (value == null) { return; }\n\n    if (kind === 'belongsTo') {\n      deserializeRecordId(store, data, key, relationship, value);\n    } else if (kind === 'hasMany') {\n      deserializeRecordIds(store, data, key, relationship, value);\n      addUnsavedRecords(record, key, value);\n    }\n  });\n\n  return data;\n}\n\nfunction deserializeRecordId(store, data, key, relationship, id) {\n  if (isNone(id) || id instanceof DS.Model) {\n    return;\n  }\n\n  var type;\n\n  if (typeof id === 'number' || typeof id === 'string') {\n    type = typeFor(relationship, key, data);\n    data[key] = store.recordForId(type, id);\n  } else if (typeof id === 'object') {\n    // polymorphic\n    data[key] = store.recordForId(id.type, id.id);\n  }\n}\n\nfunction typeFor(relationship, key, data) {\n  if (relationship.options.polymorphic) {\n    return data[key + \"Type\"];\n  } else {\n    return relationship.type;\n  }\n}\n\nfunction deserializeRecordIds(store, data, key, relationship, ids) {\n  for (var i=0, l=ids.length; i<l; i++) {\n    deserializeRecordId(store, ids, i, relationship, ids[i]);\n  }\n}\n\n// If there are any unsaved records that are in a hasMany they won't be\n// in the payload, so add them back in manually.\nfunction addUnsavedRecords(record, key, data) {\n  if(record) {\n    data.pushObjects(record.get(key).filterBy('isNew'));\n  }\n}\n\n// Delegation to the adapter and promise management\n\nDS.PromiseArray = Ember.ArrayProxy.extend(Ember.PromiseProxyMixin);\nDS.PromiseObject = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);\n\nfunction promiseObject(promise) {\n  return DS.PromiseObject.create({ promise: promise });\n}\n\nfunction promiseArray(promise) {\n  return DS.PromiseArray.create({ promise: promise });\n}\n\nfunction isThenable(object) {\n  return object && typeof object.then === 'function';\n}\n\nfunction serializerFor(container, type, defaultSerializer) {\n  return container.lookup('serializer:'+type) ||\n                 container.lookup('serializer:application') ||\n                 container.lookup('serializer:' + defaultSerializer) ||\n                 container.lookup('serializer:_default');\n}\n\nfunction defaultSerializer(container) {\n  return container.lookup('serializer:application') ||\n         container.lookup('serializer:_default');\n}\n\nfunction serializerForAdapter(adapter, type) {\n  var serializer = adapter.serializer,\n      defaultSerializer = adapter.defaultSerializer,\n      container = adapter.container;\n\n  if (container && serializer === undefined) {\n    serializer = serializerFor(container, type.typeKey, defaultSerializer);\n  }\n\n  if (serializer === null || serializer === undefined) {\n    serializer = {\n      extract: function(store, type, payload) { return payload; }\n    };\n  }\n\n  return serializer;\n}\n\nfunction _find(adapter, store, type, id) {\n  var promise = adapter.find(store, type, id),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise, \"DS: Handle Adapter#find of \" + type + \" with id: \" + id).then(function(payload) {\n    Ember.assert(\"You made a request for a \" + type.typeKey + \" with id \" + id + \", but the adapter's response did not have any data\", payload);\n    payload = serializer.extract(store, type, payload, id, 'find');\n\n    return store.push(type, payload);\n  }, function(error) {\n    var record = store.getById(type, id);\n    record.notFound();\n    throw error;\n  }, \"DS: Extract payload of '\" + type + \"'\");\n}\n\nfunction _findMany(adapter, store, type, ids, owner) {\n  var promise = adapter.findMany(store, type, ids, owner),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise, \"DS: Handle Adapter#findMany of \" + type).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findMany');\n\n    Ember.assert(\"The response from a findMany must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    store.pushMany(type, payload);\n  }, null, \"DS: Extract payload of \" + type);\n}\n\nfunction _findHasMany(adapter, store, record, link, relationship) {\n  var promise = adapter.findHasMany(store, record, link, relationship),\n      serializer = serializerForAdapter(adapter, relationship.type);\n\n  return resolve(promise, \"DS: Handle Adapter#findHasMany of \" + record + \" : \" + relationship.type).then(function(payload) {\n    payload = serializer.extract(store, relationship.type, payload, null, 'findHasMany');\n\n    Ember.assert(\"The response from a findHasMany must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    var records = store.pushMany(relationship.type, payload);\n    record.updateHasMany(relationship.key, records);\n  }, null, \"DS: Extract payload of \" + record + \" : hasMany \" + relationship.type);\n}\n\nfunction _findBelongsTo(adapter, store, record, link, relationship) {\n  var promise = adapter.findBelongsTo(store, record, link, relationship),\n      serializer = serializerForAdapter(adapter, relationship.type);\n\n  return resolve(promise, \"DS: Handle Adapter#findBelongsTo of \" + record + \" : \" + relationship.type).then(function(payload) {\n    payload = serializer.extract(store, relationship.type, payload, null, 'findBelongsTo');\n\n    var record = store.push(relationship.type, payload);\n    record.updateBelongsTo(relationship.key, record);\n    return record;\n  }, null, \"DS: Extract payload of \" + record + \" : \" + relationship.type);\n}\n\nfunction _findAll(adapter, store, type, sinceToken) {\n  var promise = adapter.findAll(store, type, sinceToken),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise, \"DS: Handle Adapter#findAll of \" + type).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findAll');\n\n    Ember.assert(\"The response from a findAll must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    store.pushMany(type, payload);\n    store.didUpdateAll(type);\n    return store.all(type);\n  }, null, \"DS: Extract payload of findAll \" + type);\n}\n\nfunction _findQuery(adapter, store, type, query, recordArray) {\n  var promise = adapter.findQuery(store, type, query, recordArray),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise, \"DS: Handle Adapter#findQuery of \" + type).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findQuery');\n\n    Ember.assert(\"The response from a findQuery must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    recordArray.load(payload);\n    return recordArray;\n  }, null, \"DS: Extract payload of findQuery \" + type);\n}\n\nfunction _commit(adapter, store, operation, record) {\n  var type = record.constructor,\n      promise = adapter[operation](store, type, record),\n      serializer = serializerForAdapter(adapter, type);\n\n  Ember.assert(\"Your adapter's '\" + operation + \"' method must return a promise, but it returned \" + promise, isThenable(promise));\n\n  return promise.then(function(payload) {\n    if (payload) { payload = serializer.extract(store, type, payload, get(record, 'id'), operation); }\n    store.didSaveRecord(record, payload);\n    return record;\n  }, function(reason) {\n    if (reason instanceof DS.InvalidError) {\n      store.recordWasInvalid(record, reason.errors);\n    } else {\n      store.recordWasError(record, reason);\n    }\n\n    throw reason;\n  }, \"DS: Extract and notify about \" + operation + \" completion of \" + record);\n}\n\n})();\n//@ sourceURL=ember-data/system/store");minispade.register('ember-data/transforms/base', "(function() {/**\n  The `DS.Transform` class is used to serialize and deserialize model\n  attributes when they are saved or loaded from an\n  adapter. Subclassing `DS.Transform` is useful for creating custom\n  attributes. All subclasses of `DS.Transform` must implement a\n  `serialize` and a `deserialize` method.\n\n  Example\n\n  ```javascript\n  App.RawTransform = DS.Transform.extend({\n    deserialize: function(serialized) {\n      return serialized;\n    },\n    serialize: function(deserialized) {\n      return deserialized;\n    }\n  });\n  ```\n\n  Usage\n\n  ```javascript\n  var attr = DS.attr;\n  App.Requirement = DS.Model.extend({\n    name: attr('string'),\n    optionsArray: attr('raw')\n  });\n  ```\n\n  @class Transform\n  @namespace DS\n */\nDS.Transform = Ember.Object.extend({\n  /**\n    When given a deserialized value from a record attribute this\n    method must return the serialized value.\n\n    Example\n\n    ```javascript\n    serialize: function(deserialized) {\n      return Ember.isEmpty(deserialized) ? null : Number(deserialized);\n    }\n    ```\n\n    @method serialize\n    @param deserialized The deserialized value\n    @return The serialized value\n  */\n  serialize: Ember.required(),\n\n  /**\n    When given a serialize value from a JSON object this method must\n    return the deserialized value for the record attribute.\n\n    Example\n\n    ```javascript\n    deserialize: function(serialized) {\n      return empty(serialized) ? null : Number(serialized);\n    }\n    ```\n\n    @method deserialize\n    @param serialized The serialized value\n    @return The deserialized value\n  */\n  deserialize: Ember.required()\n\n});\n\n})();\n//@ sourceURL=ember-data/transforms/base");minispade.register('ember-data/transforms/boolean', "(function() {\n/**\n  The `DS.BooleanTransform` class is used to serialize and deserialize\n  boolean attributes on Ember Data record objects. This transform is\n  used when `boolean` is passed as the type parameter to the\n  [DS.attr](../../data#method_attr) function.\n\n  Usage\n\n  ```javascript\n  var attr = DS.attr;\n  App.User = DS.Model.extend({\n    isAdmin: attr('boolean'),\n    name: attr('string'),\n    email: attr('string')\n  });\n  ```\n\n  @class BooleanTransform\n  @extends DS.Transform\n  @namespace DS\n */\nDS.BooleanTransform = DS.Transform.extend({\n  deserialize: function(serialized) {\n    var type = typeof serialized;\n\n    if (type === \"boolean\") {\n      return serialized;\n    } else if (type === \"string\") {\n      return serialized.match(/^true$|^t$|^1$/i) !== null;\n    } else if (type === \"number\") {\n      return serialized === 1;\n    } else {\n      return false;\n    }\n  },\n\n  serialize: function(deserialized) {\n    return Boolean(deserialized);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/transforms/boolean");minispade.register('ember-data/transforms/date', "(function() {/**\n  The `DS.DateTransform` class is used to serialize and deserialize\n  date attributes on Ember Data record objects. This transform is used\n  when `date` is passed as the type parameter to the\n  [DS.attr](../../data#method_attr) function.\n\n  ```javascript\n  var attr = DS.attr;\n  App.Score = DS.Model.extend({\n    value: attr('number'),\n    player: DS.belongsTo('player'),\n    date: attr('date')\n  });\n  ```\n\n  @class DateTransform\n  @extends DS.Transform\n  @namespace DS\n */\nDS.DateTransform = DS.Transform.extend({\n\n  deserialize: function(serialized) {\n    var type = typeof serialized;\n\n    if (type === \"string\") {\n      return new Date(Ember.Date.parse(serialized));\n    } else if (type === \"number\") {\n      return new Date(serialized);\n    } else if (serialized === null || serialized === undefined) {\n      // if the value is not present in the data,\n      // return undefined, not null.\n      return serialized;\n    } else {\n      return null;\n    }\n  },\n\n  serialize: function(date) {\n    if (date instanceof Date) {\n      var days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n      var months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n      var pad = function(num) {\n        return num < 10 ? \"0\"+num : \"\"+num;\n      };\n\n      var utcYear = date.getUTCFullYear(),\n          utcMonth = date.getUTCMonth(),\n          utcDayOfMonth = date.getUTCDate(),\n          utcDay = date.getUTCDay(),\n          utcHours = date.getUTCHours(),\n          utcMinutes = date.getUTCMinutes(),\n          utcSeconds = date.getUTCSeconds();\n\n\n      var dayOfWeek = days[utcDay];\n      var dayOfMonth = pad(utcDayOfMonth);\n      var month = months[utcMonth];\n\n      return dayOfWeek + \", \" + dayOfMonth + \" \" + month + \" \" + utcYear + \" \" +\n             pad(utcHours) + \":\" + pad(utcMinutes) + \":\" + pad(utcSeconds) + \" GMT\";\n    } else {\n      return null;\n    }\n  } \n\n});\n\n})();\n//@ sourceURL=ember-data/transforms/date");minispade.register('ember-data/transforms/index', "(function() {minispade.require('ember-data/transforms/base');\nminispade.require('ember-data/transforms/boolean');\nminispade.require('ember-data/transforms/date');\nminispade.require('ember-data/transforms/number');\nminispade.require('ember-data/transforms/string');\n})();\n//@ sourceURL=ember-data/transforms/index");minispade.register('ember-data/transforms/number', "(function() {var empty = Ember.isEmpty;\n/**\n  The `DS.NumberTransform` class is used to serialize and deserialize\n  numeric attributes on Ember Data record objects. This transform is\n  used when `number` is passed as the type parameter to the\n  [DS.attr](../../data#method_attr) function.\n\n  Usage\n\n  ```javascript\n  var attr = DS.attr;\n  App.Score = DS.Model.extend({\n    value: attr('number'),\n    player: DS.belongsTo('player'),\n    date: attr('date')\n  });\n  ```\n\n  @class NumberTransform\n  @extends DS.Transform\n  @namespace DS\n */\nDS.NumberTransform = DS.Transform.extend({\n\n  deserialize: function(serialized) {\n    return empty(serialized) ? null : Number(serialized);\n  },\n\n  serialize: function(deserialized) {\n    return empty(deserialized) ? null : Number(deserialized);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/transforms/number");minispade.register('ember-data/transforms/string', "(function() {var none = Ember.isNone;\n\n/**\n  The `DS.StringTransform` class is used to serialize and deserialize\n  string attributes on Ember Data record objects. This transform is\n  used when `string` is passed as the type parameter to the\n  [DS.attr](../../data#method_attr) function.\n\n  Usage\n\n  ```javascript\n  var attr = DS.attr;\n  App.User = DS.Model.extend({\n    isAdmin: attr('boolean'),\n    name: attr('string'),\n    email: attr('string')\n  });\n  ```\n\n  @class StringTransform\n  @extends DS.Transform\n  @namespace DS\n */\nDS.StringTransform = DS.Transform.extend({\n\n  deserialize: function(serialized) {\n    return none(serialized) ? null : String(serialized);\n  },\n\n  serialize: function(deserialized) {\n    return none(deserialized) ? null : String(deserialized);\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/transforms/string");minispade.register('ember-inflector/ext/string', "(function() {minispade.require('ember-inflector/system/string');\n\nif (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.String) {\n  /**\n    See {{#crossLink \"Ember.String/pluralize\"}}{{/crossLink}}\n\n    @method pluralize\n    @for String\n  */\n  String.prototype.pluralize = function() {\n    return Ember.String.pluralize(this);\n  };\n\n  /**\n    See {{#crossLink \"Ember.String/singularize\"}}{{/crossLink}}\n\n    @method singularize\n    @for String\n  */\n  String.prototype.singularize = function() {\n    return Ember.String.singularize(this);\n  };\n}\n\n})();\n//@ sourceURL=ember-inflector/ext/string");minispade.register('ember-inflector', "(function() {minispade.require('ember-inflector/system');\n\n})();\n//@ sourceURL=ember-inflector");minispade.register('ember-inflector/system', "(function() {minispade.require('ember-inflector/system/string');\r\nminispade.require('ember-inflector/system/inflector');\r\nminispade.require('ember-inflector/system/inflections');\r\nminispade.require('ember-inflector/ext/string');\r\n\r\nEmber.Inflector.inflector = new Ember.Inflector(Ember.Inflector.defaultRules);\r\n\n})();\n//@ sourceURL=ember-inflector/system");minispade.register('ember-inflector/system/inflections', "(function() {Ember.Inflector.defaultRules = {\n  plurals: [\n    [/$/, 's'],\n    [/s$/i, 's'],\n    [/^(ax|test)is$/i, '$1es'],\n    [/(octop|vir)us$/i, '$1i'],\n    [/(octop|vir)i$/i, '$1i'],\n    [/(alias|status)$/i, '$1es'],\n    [/(bu)s$/i, '$1ses'],\n    [/(buffal|tomat)o$/i, '$1oes'],\n    [/([ti])um$/i, '$1a'],\n    [/([ti])a$/i, '$1a'],\n    [/sis$/i, 'ses'],\n    [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'],\n    [/(hive)$/i, '$1s'],\n    [/([^aeiouy]|qu)y$/i, '$1ies'],\n    [/(x|ch|ss|sh)$/i, '$1es'],\n    [/(matr|vert|ind)(?:ix|ex)$/i, '$1ices'],\n    [/^(m|l)ouse$/i, '$1ice'],\n    [/^(m|l)ice$/i, '$1ice'],\n    [/^(ox)$/i, '$1en'],\n    [/^(oxen)$/i, '$1'],\n    [/(quiz)$/i, '$1zes']\n  ],\n\n  singular: [\n    [/s$/i, ''],\n    [/(ss)$/i, '$1'],\n    [/(n)ews$/i, '$1ews'],\n    [/([ti])a$/i, '$1um'],\n    [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i, '$1sis'],\n    [/(^analy)(sis|ses)$/i, '$1sis'],\n    [/([^f])ves$/i, '$1fe'],\n    [/(hive)s$/i, '$1'],\n    [/(tive)s$/i, '$1'],\n    [/([lr])ves$/i, '$1f'],\n    [/([^aeiouy]|qu)ies$/i, '$1y'],\n    [/(s)eries$/i, '$1eries'],\n    [/(m)ovies$/i, '$1ovie'],\n    [/(x|ch|ss|sh)es$/i, '$1'],\n    [/^(m|l)ice$/i, '$1ouse'],\n    [/(bus)(es)?$/i, '$1'],\n    [/(o)es$/i, '$1'],\n    [/(shoe)s$/i, '$1'],\n    [/(cris|test)(is|es)$/i, '$1is'],\n    [/^(a)x[ie]s$/i, '$1xis'],\n    [/(octop|vir)(us|i)$/i, '$1us'],\n    [/(alias|status)(es)?$/i, '$1'],\n    [/^(ox)en/i, '$1'],\n    [/(vert|ind)ices$/i, '$1ex'],\n    [/(matr)ices$/i, '$1ix'],\n    [/(quiz)zes$/i, '$1'],\n    [/(database)s$/i, '$1']\n  ],\n\n  irregularPairs: [\n    ['person', 'people'],\n    ['man', 'men'],\n    ['child', 'children'],\n    ['sex', 'sexes'],\n    ['move', 'moves'],\n    ['cow', 'kine'],\n    ['zombie', 'zombies']\n  ],\n\n  uncountable: [\n    'equipment',\n    'information',\n    'rice',\n    'money',\n    'species',\n    'series',\n    'fish',\n    'sheep',\n    'jeans',\n    'police'\n  ]\n};\n\n})();\n//@ sourceURL=ember-inflector/system/inflections");minispade.register('ember-inflector/system/inflector', "(function() {var BLANK_REGEX = /^\\s*$/;\n\nfunction loadUncountable(rules, uncountable) {\n  for (var i = 0, length = uncountable.length; i < length; i++) {\n    rules.uncountable[uncountable[i].toLowerCase()] = true;\n  }\n}\n\nfunction loadIrregular(rules, irregularPairs) {\n  var pair;\n\n  for (var i = 0, length = irregularPairs.length; i < length; i++) {\n    pair = irregularPairs[i];\n\n    rules.irregular[pair[0].toLowerCase()] = pair[1];\n    rules.irregularInverse[pair[1].toLowerCase()] = pair[0];\n  }\n}\n\n/**\n  Inflector.Ember provides a mechanism for supplying inflection rules for your\n  application. Ember includes a default set of inflection rules, and provides an\n  API for providing additional rules.\n\n  Examples:\n\n  Creating an inflector with no rules.\n\n  ```js\n  var inflector = new Ember.Inflector();\n  ```\n\n  Creating an inflector with the default ember ruleset.\n\n  ```js\n  var inflector = new Ember.Inflector(Ember.Inflector.defaultRules);\n\n  inflector.pluralize('cow') //=> 'kine'\n  inflector.singularize('kine') //=> 'cow'\n  ```\n\n  Creating an inflector and adding rules later.\n\n  ```javascript\n  var inflector = Ember.Inflector.inflector;\n\n  inflector.pluralize('advice') // => 'advices'\n  inflector.uncountable('advice');\n  inflector.pluralize('advice') // => 'advice'\n\n  inflector.pluralize('formula') // => 'formulas'\n  inflector.irregular('formula', 'formulae');\n  inflector.pluralize('formula') // => 'formulae'\n\n  // you would not need to add these as they are the default rules\n  inflector.plural(/$/, 's');\n  inflector.singular(/s$/i, '');\n  ```\n\n  Creating an inflector with a nondefault ruleset.\n\n  ```javascript\n  var rules = {\n    plurals:  [ /$/, 's' ],\n    singular: [ /\\s$/, '' ],\n    irregularPairs: [\n      [ 'cow', 'kine' ]\n    ],\n    uncountable: [ 'fish' ]\n  };\n\n  var inflector = new Ember.Inflector(rules);\n  ```\n\n  @class Inflector\n  @namespace Ember\n*/\nfunction Inflector(ruleSet) {\n  ruleSet = ruleSet || {};\n  ruleSet.uncountable = ruleSet.uncountable || {};\n  ruleSet.irregularPairs = ruleSet.irregularPairs || {};\n\n  var rules = this.rules = {\n    plurals:  ruleSet.plurals || [],\n    singular: ruleSet.singular || [],\n    irregular: {},\n    irregularInverse: {},\n    uncountable: {}\n  };\n\n  loadUncountable(rules, ruleSet.uncountable);\n  loadIrregular(rules, ruleSet.irregularPairs);\n}\n\nInflector.prototype = {\n  /**\n    @method plural\n    @param {RegExp} regex\n    @param {String} string\n  */\n  plural: function(regex, string) {\n    this.rules.plurals.push([regex, string.toLowerCase()]);\n  },\n\n  /**\n    @method singular\n    @param {RegExp} regex\n    @param {String} string\n  */\n  singular: function(regex, string) {\n    this.rules.singular.push([regex, string.toLowerCase()]);\n  },\n\n  /**\n    @method uncountable\n    @param {String} regex\n  */\n  uncountable: function(string) {\n    loadUncountable(this.rules, [string.toLowerCase()]);\n  },\n\n  /**\n    @method irregular\n    @param {String} singular\n    @param {String} plural\n  */\n  irregular: function (singular, plural) {\n    loadIrregular(this.rules, [[singular, plural]]);\n  },\n\n  /**\n    @method pluralize\n    @param {String} word\n  */\n  pluralize: function(word) {\n    return this.inflect(word, this.rules.plurals, this.rules.irregular);\n  },\n\n  /**\n    @method singularize\n    @param {String} word\n  */\n  singularize: function(word) {\n    return this.inflect(word, this.rules.singular,  this.rules.irregularInverse);\n  },\n\n  /**\n    @protected\n\n    @method inflect\n    @param {String} word\n    @param {Object} typeRules\n    @param {Object} irregular\n  */\n  inflect: function(word, typeRules, irregular) {\n    var inflection, substitution, result, lowercase, isBlank,\n    isUncountable, isIrregular, isIrregularInverse, rule;\n\n    isBlank = BLANK_REGEX.test(word);\n\n    if (isBlank) {\n      return word;\n    }\n\n    lowercase = word.toLowerCase();\n\n    isUncountable = this.rules.uncountable[lowercase];\n\n    if (isUncountable) {\n      return word;\n    }\n\n    isIrregular = irregular && irregular[lowercase];\n\n    if (isIrregular) {\n      return isIrregular;\n    }\n\n    for (var i = typeRules.length, min = 0; i > min; i--) {\n       inflection = typeRules[i-1];\n       rule = inflection[0];\n\n      if (rule.test(word)) {\n        break;\n      }\n    }\n\n    inflection = inflection || [];\n\n    rule = inflection[0];\n    substitution = inflection[1];\n\n    result = word.replace(rule, substitution);\n\n    return result;\n  }\n};\n\nEmber.Inflector = Inflector;\n\n})();\n//@ sourceURL=ember-inflector/system/inflector");minispade.register('ember-inflector/system/string', "(function() {Ember.String.pluralize = function(word) {\n  return Ember.Inflector.inflector.pluralize(word);\n};\n\nEmber.String.singularize = function(word) {\n  return Ember.Inflector.inflector.singularize(word);\n};\n\n})();\n//@ sourceURL=ember-inflector/system/string");